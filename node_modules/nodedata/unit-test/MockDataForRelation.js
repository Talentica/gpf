"use strict";
require('reflect-metadata/reflect');
const Mongoose = require("mongoose");
const course_1 = require('./models/course');
const student_1 = require('./models/student');
const Enumerable = require('linq');
var Q = require('q');
var database = {};
var _mongooseModel = {};
var _databaseCalls = {};
class ModelNames {
}
ModelNames.course = course_1.course.prototype.constructor.name;
ModelNames.student = student_1.student.prototype.constructor.name;
class courseRepository {
    find(param) {
        return MongoDbMock.find(param, database[ModelNames.course]);
    }
    findOne(param) {
        return MongoDbMock.findOne(param, database[ModelNames.course]);
    }
    create(object) {
        return MongoDbMock.create(object, _mongooseModel[ModelNames.course], database[ModelNames.course]);
    }
    findOneAndRemove(query) {
        return MongoDbMock.findOneAndRemove(query, database[ModelNames.course]);
    }
    findOneAndUpdate(query, object, param) {
        return MongoDbMock.findOneAndUpdate(query, object, param, database[ModelNames.course]);
    }
    update(query, object, param) {
        return MongoDbMock.update(query, object, param, database[ModelNames.course]);
    }
}
class studentRepository {
    find(param) {
        return MongoDbMock.find(param, database[ModelNames.student]);
    }
    findOne(param) {
        return MongoDbMock.findOne(param, database[ModelNames.student]);
    }
    create(object) {
        return MongoDbMock.create(object, _mongooseModel[ModelNames.student], database[ModelNames.student]);
    }
    findOneAndRemove(query) {
        return MongoDbMock.findOneAndRemove(query, database[ModelNames.student]);
    }
    findOneAndUpdate(query, object, param) {
        return MongoDbMock.findOneAndUpdate(query, object, param, database[ModelNames.student]);
    }
    update(query, object, param) {
        return MongoDbMock.update(query, object, param, database[ModelNames.student]);
    }
}
class MongoDbMock {
    static setEmptytoObject(obj) {
        if (obj == undefined || obj != {}) {
            obj['toObject'] = function () {
                return {};
            };
        }
    }
    static find(param, collection) {
        var res = [];
        if (JSON.stringify(param) === JSON.stringify({})) {
            res = collection;
        }
        else {
            var prop;
            for (var p in param) {
                prop = p;
                break;
            }
            if (prop == '_id') {
                if (param[prop]['$in']) {
                    var arr = param[prop]['$in'];
                    res = Enumerable.from(collection).where(x => arr.find(id => x['_id'] == id.toString())).toArray();
                }
                else {
                    res = Enumerable.from(collection).where(x => x['_doc'][prop] == param[prop].toString()).firstOrDefault();
                }
            }
            else {
                var arr = param[prop]['$in'];
                if (arr) {
                    Enumerable.from(collection).forEach(x => {
                        if (x['_doc'][prop]) {
                            var f = x['_doc'][prop].find(x => arr.find(id => x.toString() == id));
                            if (f) {
                                res.push(x);
                            }
                        }
                    });
                }
                else {
                    res = Enumerable.from(collection).where(x => x['_doc'][prop] == param[prop].toString()).firstOrDefault();
                }
            }
        }
        //console.log('find (', param, ') => ', res);
        return Q.when(res);
    }
    static findOne(param, collection) {
        var res = {};
        for (var item in param) {
            var id = param[item].toString();
            res = Enumerable.from(collection).where(x => x['_doc'][item] == param[item].toString()).firstOrDefault();
            break;
        }
        //console.log('findOne (', param, ') => ', res);
        return Q.when(res);
    }
    static create(object, model, collection) {
        var res;
        if (object instanceof Array) {
            res = [];
            Enumerable.from(object).forEach(x => {
                var obj = new model(x);
                collection.push(obj);
                res.push(obj);
            });
        }
        else {
            var obj = new model(object);
            collection.push(obj);
            res = obj;
        }
        //console.log('create(', object, ')=> ', obj);
        return Q.when(res);
    }
    static findOneAndRemove(query, collection) {
        var res = {};
        for (var item in query) {
            res = Enumerable.from(collection).where(x => x['_doc'][item] == query[item].toString()).firstOrDefault();
            if (res) {
                collection.splice(collection.indexOf(res), 1);
            }
            break;
        }
        //console.log('findOneAndRemove (', query, ') => ', res);
        return Q.when(res);
    }
    static findOneAndUpdate(query, object, param, collection) {
        var res = {};
        for (var item in query) {
            res = Enumerable.from(collection).where(x => x['_doc'][item] == query[item].toString()).firstOrDefault();
            if (res) {
                var setObject, unsetObject, pushObject;
                if (object['$set']) {
                    setObject = object['$set'];
                }
                if (object['$unset']) {
                    unsetObject = object['$unset'];
                }
                if (object['$push']) {
                    pushObject = object['$push'];
                }
                for (var prop in setObject) {
                    res['_doc'][prop] = setObject[prop];
                }
                for (var prop in unsetObject) {
                    delete res['_doc'][prop];
                }
                for (var prop in pushObject) {
                    var vals = pushObject[prop]['$each'];
                    if (!res['_doc'][prop]) {
                        res['_doc'][prop] = [];
                    }
                    Enumerable.from(vals).forEach(x => res['_doc'][prop].push(x));
                }
            }
            break;
        }
        //console.log('findOneAndUpdate (', query, object, param, ') => ', res);
        return Q.when(res);
    }
    static update(query, object, param, collection) {
        var res = [];
        if (JSON.stringify(query) === JSON.stringify(MongoDbMock.updateCondition) ||
            (JSON.stringify(query) === JSON.stringify({}) &&
                JSON.stringify(object) === JSON.stringify(MongoDbMock.updateCondition))) {
            var id = MongoDbMock.updateResult['_id'].toString();
            res = collection.find(x => x['_id'] == id);
            for (var ind in MongoDbMock.updateResult) {
                res['_doc'][ind] = MongoDbMock.updateResult[ind];
            }
            res = [res];
        }
        //console.log('update (', query, object, param), ') =>', res);
        return Q.when(res);
    }
    static setOnUpdate(model, cond, object) {
        //console.log('setOnUpdate - ', cond, object);
        MongoDbMock.updateCondition = cond;
        MongoDbMock.updateResult = object;
    }
}
exports.MongoDbMock = MongoDbMock;
function AddAllFakeFunctions() {
    database[ModelNames.course] = [];
    _mongooseModel[ModelNames.course] = Mongoose.model(ModelNames.course, new Mongoose.Schema(course_1.course.prototype.schema()));
    _databaseCalls[ModelNames.course] = new courseRepository();
    database[ModelNames.student] = [];
    _mongooseModel[ModelNames.student] = Mongoose.model(ModelNames.student, new Mongoose.Schema(student_1.student.prototype.schema()));
    _databaseCalls[ModelNames.student] = new studentRepository();
    console.log('added all faked function');
}
exports.AddAllFakeFunctions = AddAllFakeFunctions;
function createMongooseModel(name, object) {
    object['_id'] = new Mongoose.Types.ObjectId();
    var model = new _mongooseModel[name.prototype.constructor.name](object);
    database[name.prototype.constructor.name].push(model);
    return model;
}
exports.createMongooseModel = createMongooseModel;
function getMongooseModel(name) {
    return _mongooseModel[name.prototype.constructor.name];
}
exports.getMongooseModel = getMongooseModel;
function getFakeFunctionForMongoose(func, model) {
    var fn = func;
    var res = _databaseCalls[model.modelName][func.name];
    if (!res) {
        //console.log('return fake function - ', model.modelName, fn.length, fn.arguments, fn);
        if (fn.length == 4) {
            return _databaseCalls[model.modelName]['findOneAndUpdate'];
        }
        else if (fn.length == 3) {
            return _databaseCalls[model.modelName]['findOneAndRemove'];
        }
    }
    return res;
}
exports.getFakeFunctionForMongoose = getFakeFunctionForMongoose;
function clearDatabase() {
    database[ModelNames.course] = [];
    database[ModelNames.student] = [];
}
exports.clearDatabase = clearDatabase;
class mockedFunctions {
    castToMongooseType(value, schemaType) {
        //console.log('castToMongooseType - ', value, schemaType);
        if (value['_id']) {
            return value['_id'];
        }
        else {
            return value;
        }
    }
    getEntity(object) {
        //console.log('getEntity - ', object);
        switch (object) {
            case ModelNames.course:
                return course_1.course;
            case ModelNames.student:
                return student_1.student;
        }
    }
    getModel(object) {
        //console.log('getModel - ', object);
        return _mongooseModel[object];
    }
    getDbSpecifcModel(object, schema) {
        return _mongooseModel[object];
    }
}
exports.mockedFunctions = mockedFunctions;
//# sourceMappingURL=MockDataForRelation.js.map