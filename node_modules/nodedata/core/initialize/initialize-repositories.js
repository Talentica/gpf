"use strict";
const utils_1 = require("../metadata/utils");
const Utils = require("../utils");
const dynamic_repository_1 = require('../dynamic/dynamic-repository');
const instance_service_1 = require('../services/instance-service');
var Config = Utils.config();
const constants_1 = require('../constants');
const repositories_1 = require('../exports/repositories');
const Enumerable = require('linq');
exports.mongooseNameSchemaMap = {};
class InitializeRepositories {
    constructor() {
        this.initializeRepo();
    }
    schemaGenerator(schemaGenerator) {
        this._schemaGenerator = schemaGenerator;
    }
    initializeRepo() {
        let repositories = utils_1.MetaUtils.getMetaDataForDecorators([constants_1.Decorators.REPOSITORY]);
        let repoMap = {};
        Enumerable.from(repositories)
            .forEach((x) => {
            if (!x.metadata || !x.metadata.length) {
                return;
            }
            //let params = <IRepositoryParams>x.metadata[0].params;
            //let repositoryModel = MetaUtils.getMetaData(params.model.prototype, Decorators.DOCUMENT);
            //let schemaName = (<IDocumentParams>repositoryModel.params).name; // model name i.e. schema name
            //let schema = new DynamicSchema(params.model, schemaName);
            //let mongooseSchema = schema.getSchema();
            //mongooseSchemaMap[(<any>x.target).path] = { schema: mongooseSchema, name: schema.schemaName, fn: x.target };
            //mongooseNameSchemaMap[schema.schemaName] = mongooseSchema;
            let path = x.target.path;
            let repoParams = x.metadata[0].params;
            let model = repoParams.model;
            let newRepo;
            let rootRepo = new dynamic_repository_1.DynamicRepository();
            rootRepo.initialize(repoParams.path, x.target, model);
            if (x.target instanceof dynamic_repository_1.DynamicRepository) {
                newRepo = instance_service_1.InstanceService.getInstance(x.target, null, null);
            }
            else {
                newRepo = rootRepo;
            }
            newRepo.initialize(repoParams.path, x.target, model, rootRepo);
            repoMap[path] = {
                fn: x.target,
                repo: newRepo
            };
            //searchMetaUtils.registerToMongoosastic(repoMap[path].repo.getModel());
        });
        //let repoMap: { [key: string]: { fn: Object, repo: IDynamicRepository } } = <any>{};
        //for (var path in mongooseSchemaMap) {
        //    var schemaMapVal = mongooseSchemaMap[path];
        //    if (!schemaNameModel[schemaMapVal.name]) {
        //        schemaNameModel[schemaMapVal.name] = { entity: schemaMapVal.fn.model, model: Mongoose.model(schemaMapVal.name, schemaMapVal.schema) };
        //    }
        //    repoMap[path] = {
        //        fn: mongooseSchemaMap[path].fn,
        //        repo: new DynamicRepository(schemaMapVal.name, GetEntity(schemaMapVal.name), GetModel(schemaMapVal.name), schemaMapVal.fn)
        //    };
        //    searchMetaUtils.registerToMongoosastic(repoMap[path].repo.getModel());
        //}
        repositories_1.repositoryMap(repoMap);
    }
}
exports.InitializeRepositories = InitializeRepositories;

//# sourceMappingURL=initialize-repositories.js.map
