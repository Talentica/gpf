{"version":3,"sources":["core/initialize/initialize-repositories.ts"],"names":[],"mappings":";AAAA,wBAAwB,mBAAmB,CAAC,CAAA;AAC5C,MAAY,KAAK,WAAM,UAAU,CAAC,CAAA;AAGlC,qCAAoD,+BAA+B,CAAC,CAAA;AACpF,mCAA8B,8BAA8B,CAAC,CAAA;AAG7D,IAAI,MAAM,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC;AAC5B,4BAAyB,cAAc,CAAC,CAAA;AAGxC,+BAA4B,yBAAyB,CAAC,CAAA;AAItD,MAAY,UAAU,WAAM,MAAM,CAAC,CAAA;AAExB,6BAAqB,GAA2B,EAAE,CAAC;AAE9D;IAGI;QACI,IAAI,CAAC,cAAc,EAAE,CAAC;IAC1B,CAAC;IAEM,eAAe,CAAC,eAAiC;QACpD,IAAI,CAAC,gBAAgB,GAAG,eAAe,CAAC;IAC5C,CAAC;IAEO,cAAc;QAClB,IAAI,YAAY,GAAG,iBAAS,CAAC,wBAAwB,CAAC,CAAC,sBAAU,CAAC,UAAU,CAAC,CAAC,CAAC;QAE/E,IAAI,OAAO,GAAqE,EAAE,CAAC;QAEnF,UAAU,CAAC,IAAI,CAAC,YAAY,CAAC;aACxB,OAAO,CAAC,CAAC,CAAgD;YACtD,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,QAAQ,IAAI,CAAC,CAAC,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC;gBACpC,MAAM,CAAC;YACX,CAAC;YACD,uDAAuD;YACvD,2FAA2F;YAC3F,iGAAiG;YACjG,2DAA2D;YAC3D,0CAA0C;YAC1C,8GAA8G;YAC9G,4DAA4D;YAE5D,IAAI,IAAI,GAAS,CAAC,CAAC,MAAO,CAAC,IAAI,CAAC;YAChC,IAAI,UAAU,GAAsB,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC;YACzD,IAAI,KAAK,GAAG,UAAU,CAAC,KAAK,CAAC;YAC7B,IAAI,OAA0B,CAAC;YAC/B,IAAI,QAAQ,GAAG,IAAI,sCAAiB,EAAE,CAAC;YACvC,QAAQ,CAAC,UAAU,CAAC,UAAU,CAAC,IAAI,EAAE,CAAC,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;YACtD,EAAE,CAAC,CAAC,CAAC,CAAC,MAAM,YAAY,sCAAiB,CAAC,CAAC,CAAC;gBACxC,OAAO,GAAsB,kCAAe,CAAC,WAAW,CAAC,CAAC,CAAC,MAAM,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;YACnF,CAAC;YACD,IAAI,CAAC,CAAC;gBACF,OAAO,GAAG,QAAQ,CAAC;YACvB,CAAC;YACD,OAAO,CAAC,UAAU,CAAC,UAAU,CAAC,IAAI,EAAE,CAAC,CAAC,MAAM,EAAE,KAAK,EAAE,QAAQ,CAAC,CAAC;YAE/D,OAAO,CAAC,IAAI,CAAC,GAAG;gBACZ,EAAE,EAAE,CAAC,CAAC,MAAM;gBACZ,IAAI,EAAE,OAAO;aAChB,CAAC;YACF,wEAAwE;QAC5E,CAAC,CAAC,CAAC;QAEP,qFAAqF;QACrF,uCAAuC;QACvC,iDAAiD;QACjD,gDAAgD;QAChD,gJAAgJ;QAChJ,OAAO;QAEP,uBAAuB;QACvB,yCAAyC;QACzC,oIAAoI;QACpI,QAAQ;QACR,4EAA4E;QAC5E,GAAG;QACH,4BAAa,CAAC,OAAO,CAAC,CAAC;IAC3B,CAAC;AACL,CAAC;AAjEY,8BAAsB,yBAiElC,CAAA","file":"core/initialize/initialize-repositories.js","sourcesContent":["import {MetaUtils} from \"../metadata/utils\";\nimport * as Utils from \"../utils\";\nimport {MetaData} from '../metadata/metadata';\n\nimport {IDynamicRepository, DynamicRepository} from '../dynamic/dynamic-repository';\nimport {InstanceService} from '../services/instance-service';\nimport {ParamTypeCustom} from '../metadata/param-type-custom';\nimport {searchUtils} from \"../../search/elasticSearchUtils\";\nvar Config = Utils.config();\nimport {Decorators} from '../constants';\n\nimport {IRepositoryParams} from '../decorators/interfaces';\nimport {repositoryMap} from '../exports/repositories';\n\nimport {ISchemaGenerator} from '../interfaces/schema-generator';\n\nimport * as Enumerable from 'linq';\n\nexport var mongooseNameSchemaMap: { [key: string]: any } = {};\n\nexport class InitializeRepositories {\n    private _schemaGenerator: ISchemaGenerator;\n\n    constructor() {\n        this.initializeRepo();\n    }\n\n    public schemaGenerator(schemaGenerator: ISchemaGenerator) {\n        this._schemaGenerator = schemaGenerator;\n    }\n\n    private initializeRepo() {\n        let repositories = MetaUtils.getMetaDataForDecorators([Decorators.REPOSITORY]);\n\n        let repoMap: { [key: string]: { fn: Object, repo: IDynamicRepository } } = <any>{};\n\n        Enumerable.from(repositories)\n            .forEach((x: { target: Object, metadata: Array<MetaData> }) => {\n                if (!x.metadata || !x.metadata.length) {\n                    return;\n                }\n                //let params = <IRepositoryParams>x.metadata[0].params;\n                //let repositoryModel = MetaUtils.getMetaData(params.model.prototype, Decorators.DOCUMENT);\n                //let schemaName = (<IDocumentParams>repositoryModel.params).name; // model name i.e. schema name\n                //let schema = new DynamicSchema(params.model, schemaName);\n                //let mongooseSchema = schema.getSchema();\n                //mongooseSchemaMap[(<any>x.target).path] = { schema: mongooseSchema, name: schema.schemaName, fn: x.target };\n                //mongooseNameSchemaMap[schema.schemaName] = mongooseSchema;\n\n                let path = (<any>x.target).path;\n                let repoParams = <IRepositoryParams>x.metadata[0].params;\n                let model = repoParams.model;\n                let newRepo: DynamicRepository;\n                let rootRepo = new DynamicRepository();\n                rootRepo.initialize(repoParams.path, x.target, model);\n                if (x.target instanceof DynamicRepository) {\n                    newRepo = <DynamicRepository>InstanceService.getInstance(x.target, null, null);\n                }\n                else {\n                    newRepo = rootRepo;\n                }\n                newRepo.initialize(repoParams.path, x.target, model, rootRepo);\n\n                repoMap[path] = {\n                    fn: x.target,\n                    repo: newRepo\n                };\n                //searchMetaUtils.registerToMongoosastic(repoMap[path].repo.getModel());\n            });\n\n        //let repoMap: { [key: string]: { fn: Object, repo: IDynamicRepository } } = <any>{};\n        //for (var path in mongooseSchemaMap) {\n        //    var schemaMapVal = mongooseSchemaMap[path];\n        //    if (!schemaNameModel[schemaMapVal.name]) {\n        //        schemaNameModel[schemaMapVal.name] = { entity: schemaMapVal.fn.model, model: Mongoose.model(schemaMapVal.name, schemaMapVal.schema) };\n        //    }\n\n        //    repoMap[path] = {\n        //        fn: mongooseSchemaMap[path].fn,\n        //        repo: new DynamicRepository(schemaMapVal.name, GetEntity(schemaMapVal.name), GetModel(schemaMapVal.name), schemaMapVal.fn)\n        //    };\n        //    searchMetaUtils.registerToMongoosastic(repoMap[path].repo.getModel());\n        //}\n        repositoryMap(repoMap);\n    }\n}"],"sourceRoot":"/source/"}