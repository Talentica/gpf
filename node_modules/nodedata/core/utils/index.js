"use strict";
var Enumerable = require('linq');
const utils_1 = require('../metadata/utils');
const constants_1 = require('../constants');
const decorator_type_1 = require('../enums/decorator-type');
const model_entity_1 = require('../dynamic/model-entity');
let _config = {};
let _securityConfig = {};
let _entityService = new Map();
class resources {
}
resources.userDatabase = '_database';
exports.resources = resources;
function config(config) {
    if (!(config === undefined)) {
        _config = config;
    }
    return _config;
}
exports.config = config;
function securityConfig(securityConf) {
    if (!(securityConf === undefined)) {
        _securityConfig = securityConf;
    }
    return _securityConfig;
}
exports.securityConfig = securityConfig;
function entityService(entityType, entityService) {
    if (!_entityService[entityType] && entityService) {
        _entityService[entityType] = entityService;
    }
    return _entityService[entityType];
}
exports.entityService = entityService;
//export function sqlEntityService(sqlEntityService?: IEntityService): IEntityService {
//    if (!(sqlEntityService === undefined)) {
//        _sqlEntityService = sqlEntityService;
//    }
//    return _sqlEntityService;
//}
function getDesignType(target, prop) {
    return Reflect.getMetadata("design:type", target, prop);
}
exports.getDesignType = getDesignType;
function getDesignParamType(target, prop, parameterIndex) {
    return Reflect.getMetadata("design:paramtypes", target, prop);
}
exports.getDesignParamType = getDesignParamType;
function activator(cls, args) {
    return new (Function.prototype.bind.apply(cls, [null].concat(args)));
    //function F(): void {
    //    return <any>cls.constructor.apply(this, args);
    //}
    //F.prototype = <any>cls.constructor.prototype;
    //return new F();
}
exports.activator = activator;
function isRelationDecorator(decorator) {
    return decorator === constants_1.Decorators.ONETOMANY || decorator === constants_1.Decorators.MANYTOONE || decorator === constants_1.Decorators.MANYTOMANY || decorator === constants_1.Decorators.ONETOONE;
}
exports.isRelationDecorator = isRelationDecorator;
/**
 * Get all the metadata of all the decorators of all the models referencing current target, i.e. (rel = target relation name)
 * @param target like UserModel (function of prototype)
 *
 */
function getAllRelationsForTarget(target) {
    if (!target) {
        throw TypeError;
    }
    //global.models.CourseModel.decorator.manytomany.students
    var name = getResourceNameFromModel(target);
    if (!name) {
        return null;
    }
    var metaForRelations = utils_1.MetaUtils.getMetaDataForDecorators(constants_1.RelationDecorators);
    return Enumerable.from(metaForRelations)
        .selectMany(keyVal => keyVal.metadata)
        .where(x => x.params.rel === name)
        .toArray();
}
exports.getAllRelationsForTarget = getAllRelationsForTarget;
/**
 * Get all the metadata of all the decorators of all the models referencing current target, i.e. (rel = target relation name)
 * @param target like UserModel (function of prototype)
 *
 */
function getAllRelationsForTargetInternal(target) {
    if (!target) {
        throw TypeError;
    }
    //global.models.CourseModel.decorator.manytomany.students
    var meta = utils_1.MetaUtils.getMetaData(target);
    if (!meta) {
        return null;
    }
    return Enumerable.from(meta)
        .where((x) => {
        return constants_1.RelationDecorators.indexOf(x.decorator) !== -1;
    })
        .toArray();
}
exports.getAllRelationsForTargetInternal = getAllRelationsForTargetInternal;
function getRepoPathForChildIfDifferent(target, prop) {
    if (!target) {
        throw TypeError;
    }
    //global.models.CourseModel.decorator.manytomany.students
    var meta = utils_1.MetaUtils.getMetaData(target);
    if (!meta) {
        return null;
    }
    var type = Enumerable.from(meta).where(x => x.decoratorType == decorator_type_1.DecoratorType.CLASS).select(x => x.decorator).firstOrDefault();
    var res = Enumerable.from(meta)
        .where((x) => {
        var met = x;
        return (constants_1.RelationDecorators.indexOf(met.decorator) !== -1 && met.propertyKey === prop);
    })
        .toArray();
    if (res.length == 0)
        return null;
    meta = utils_1.MetaUtils.getMetaData(res[0].params.itemType);
    var childType = Enumerable.from(meta).where(x => x.decoratorType == decorator_type_1.DecoratorType.CLASS).firstOrDefault();
    //if (type == childType.decorator)
    //    return null;
    var repoPath;
    var param = childType.params;
    repoPath = Enumerable.from(model_entity_1.pathRepoMap).where(keyVal => model_entity_1.pathRepoMap[keyVal.key].schemaName == param.name).select(x => x.key).firstOrDefault();
    return repoPath;
}
exports.getRepoPathForChildIfDifferent = getRepoPathForChildIfDifferent;
//@document({ name: 'blogs', isStrict: false })
//export class BlogModel
//this will return 'blogs' 
function getResourceNameFromModel(object) {
    var meta = utils_1.MetaUtils.getMetaData(object, constants_1.Decorators.DOCUMENT);
    if (!meta || !meta[0] || !meta[0].params) {
        return null;
    }
    return meta[0].params.name;
}
exports.getResourceNameFromModel = getResourceNameFromModel;
//@document({ name: 'blogs', isStrict: false })
//export class BlogModel
//this will return 'blogs' 
//if calling from repo w/o object you will atleast know the name of all resources
function getAllResourceNames() {
    var resources = [];
    var meta = utils_1.MetaUtils.getMetaDataForDecorators([constants_1.Decorators.REPOSITORY]);
    return Enumerable.from(meta)
        .select(x => {
        return x.metadata[0].params.path;
    })
        .toArray();
}
exports.getAllResourceNames = getAllResourceNames;
function getPrimaryKeyMetadata(target) {
    var meta = utils_1.MetaUtils.getMetaData(target, constants_1.Decorators.FIELD);
    return Enumerable.from(meta)
        .where(keyval => keyval.params && keyval.params.primary) // keyval = {[key(propName): string]: Metadata};
        .select(keyVal => keyVal)
        .firstOrDefault();
}
exports.getPrimaryKeyMetadata = getPrimaryKeyMetadata;
function isPromise(object) {
    if (object && (object['then'] instanceof Function || object['promiseDispatch'] instanceof Function))
        return true;
    return false;
}
exports.isPromise = isPromise;
function isJSON(val) {
    if (val && val.toString() == "[object Object]")
        return true;
    return false;
}
exports.isJSON = isJSON;
//export function getAllRelationalMetaDataForField(target: Object, propertyKey?: string): Array<MetaData> {
//    if (!target) {
//        throw TypeError;
//    }
//    propertyKey = propertyKey || CLASSDECORATOR_PROPKEY;
//    var metaKey = MetadataHelper.getMetaKey(target);
//    if (!metadataRoot.get(metaKey)) {
//        return null;
//    }
//    return Enumerable.from(metadataRoot.get(metaKey))
//        .where((keyVal: any) => Utils.isRelationDecorator(keyVal.key))
//        .selectMany(keyval => keyval.value) // keyval = {[key(decoratorName): string]: {[key(propName)]: Metadata}};
//        .where(keyVal => keyVal.key === propertyKey) // keyval = {[key(propName): string]: Metadata};
//        .select(keyVal => keyVal.value) // keyval = {[key(propName): string]: Metadata};
//        .toArray();
//}
//var authenticateByToken = expressJwt({
//    secret: SecurityConfig.SecurityConfig.tokenSecretkey,
//    credentialsRequired: true,
//    getToken: function fromHeaderOrQuerystring(req) {
//        if (req.headers.authorization && req.headers.authorization.split(' ')[0] === 'Bearer') {
//            return req.headers.authorization.split(' ')[1];
//        } else if (req.query && req.query.token) {
//            return req.query.token;
//        } else if (req.cookies && req.cookies.authorization) {
//            return req.cookies.authorization;
//        }
//        return null;
//    }
//});
//export function ensureLoggedIn() {
//    if (Config.Security.isAutheticationEnabled == SecurityConfig.AuthenticationEnabled[SecurityConfig.AuthenticationEnabled.disabled]) {
//        return function (req, res, next) {
//            next();
//        }
//    }
//    //by token
//    if (Config.Security.authenticationType == SecurityConfig.AuthenticationType[SecurityConfig.AuthenticationType.TokenBased]) {
//        return authenticateByToken;
//    }
//    //by password
//    if (Config.Security.authenticationType == SecurityConfig.AuthenticationType[SecurityConfig.AuthenticationType.passwordBased]) {
//        return loggedIn();
//    }
//    return function (req, res, next) {
//        next();
//    }
//}

//# sourceMappingURL=index.js.map
