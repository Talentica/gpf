"use strict";
const configUtil = require('../utils');
const winstonLog_1 = require('../../logging/winstonLog');
const dynamic_repository_1 = require('./dynamic-repository');
var Reflect = require('reflect-metadata');
const exports_1 = require('../exports');
var jwt = require('jsonwebtoken');
const searchUtils_1 = require("../metadata/searchUtils");
const actionUtils_1 = require("../metadata/actionUtils");
const utils_1 = require("../metadata/utils");
const Utils = require("../utils");
const decorators_1 = require('../constants/decorators');
const pre_auth_service_1 = require('../services/pre-auth-service');
const repo_actions_enum_1 = require('../enums/repo-actions-enum');
const principalContext_1 = require('../../security/auth/principalContext');
const post_filter_service_1 = require('../services/post-filter-service');
const queryOptions_1 = require('../interfaces/queryOptions');
var multer = require('multer');
const securityImpl = require('./security-impl');
const Enumerable = require('linq');
var Q = require('q');
const jsonignore_enum_1 = require('../enums/jsonignore-enum');
class DynamicController {
    constructor(entity, repository) {
        this.repository = repository;
        this.entity = entity;
        this.path = "/" + Utils.config().Config.basePath + "/" + entity.path;
        this.addSearchPaths();
        this.addActionPaths();
        this.addRoutes();
    }
    ensureLoggedIn(entity, action) {
        return function (req, res, next) {
            principalContext_1.PrincipalContext.getSession().run(function () {
                var meta = utils_1.MetaUtils.getMetaData(entity, decorators_1.Decorators.ALLOWANONYMOUS, action);
                if (meta) {
                    next();
                }
                else {
                    securityImpl.ensureLoggedIn()(req, res, next);
                }
            });
        };
    }
    isAuthorize(req, res, action) {
        var meta = utils_1.MetaUtils.getMetaData(this.entity, decorators_1.Decorators.ALLOWANONYMOUS, action);
        if (meta)
            return true;
        if (securityImpl.isAuthorize(req, this.repository, action)) {
            principalContext_1.PrincipalContext.save('req', req);
            principalContext_1.PrincipalContext.save('res', res);
            return true;
        }
        return false;
    }
    addRoutes() {
        exports_1.router.get(this.path, this.ensureLoggedIn(this.entity, repo_actions_enum_1.RepoActions.findAll), (req, res) => {
            if (!this.isAuthorize(req, res, repo_actions_enum_1.RepoActions.findAll)) {
                this.sendUnauthorizeError(res, 'unauthorize access for resource ' + this.path);
                return;
            }
            return this.repository.findAll()
                .then((result) => {
                var resourceName = this.getFullBaseUrl(req); // + this.repository.modelName();
                Enumerable.from(result).forEach((x) => {
                    x = this.getHalModel1(x, resourceName + "/" + x._id, req, this.repository);
                });
                //result = this.getHalModels(result,resourceName);
                this.sendresult(req, res, result);
            }).catch(error => {
                this.sendError(res, error);
            });
        });
        exports_1.router.get(this.path + '/:id', this.ensureLoggedIn(this.entity, repo_actions_enum_1.RepoActions.findOne), (req, res) => {
            if (!this.isAuthorize(req, res, repo_actions_enum_1.RepoActions.findOne)) {
                this.sendUnauthorizeError(res, 'unauthorize access for resource ' + this.path);
                return;
            }
            return this.repository.findOne(req.params.id)
                .then((result) => {
                var resourceName = this.getFullBaseUrl(req); // + this.repository.modelName();
                this.getHalModel1(result, resourceName, req, this.repository);
                this.sendresult(req, res, result);
            }).catch(error => {
                this.sendError(res, error);
            });
        });
        exports_1.router.get(this.path + '/:id/:prop', this.ensureLoggedIn(this.entity, repo_actions_enum_1.RepoActions.findChild), (req, res) => {
            if (!this.isAuthorize(req, res, repo_actions_enum_1.RepoActions.findChild)) {
                this.sendUnauthorizeError(res, 'unauthorize access for resource ' + this.path);
                return;
            }
            return this.repository.findChild(req.params.id, req.params.prop)
                .then((result) => {
                var parentObj = {};
                parentObj[req.params.prop] = result;
                var resourceName = this.getFullBaseUrl(req);
                this.getHalModel1(parentObj, resourceName + '/' + req.params.id, req, this.repository);
                this.sendresult(req, res, parentObj[req.params.prop]);
            }).catch(error => {
                this.sendError(res, error);
            });
        });
        exports_1.router.post(this.path, this.ensureLoggedIn(this.entity, repo_actions_enum_1.RepoActions.post), (req, res) => {
            if (!this.isAuthorize(req, res, repo_actions_enum_1.RepoActions.post)) {
                this.sendUnauthorizeError(res, 'unauthorize access for resource ' + this.path);
                return;
            }
            if (!Array.isArray(req.body)) {
                this.getModelFromHalModel(req.body, req, res);
                return this.repository.post(req.body)
                    .then((result) => {
                    var resourceName = this.getFullBaseUrlUsingRepo(req, this.repository.modelName());
                    this.getHalModel1(result, resourceName + '/' + result['_id'], req, this.repository);
                    this.sendresult(req, res, result);
                }).catch(error => {
                    this.sendError(res, error);
                });
            }
            else {
                Enumerable.from(req.body).forEach(x => {
                    this.getModelFromHalModel(x, req, res);
                });
                return this.repository.bulkPost(req.body)
                    .then((result) => {
                    Enumerable.from(result).forEach(x => {
                        var resourceName = this.getFullBaseUrlUsingRepo(req, this.repository.modelName());
                        this.getHalModel1(x, resourceName + '/' + x['_id'], req, this.repository);
                    });
                    this.sendresult(req, res, result);
                }).catch(error => {
                    this.sendError(res, error);
                });
            }
        });
        //router.post(this.path + '/:id/:prop/:value', (req, res) => {
        //    return this.sendresult(req, res, req.params);
        //});
        // delete any property value
        exports_1.router.delete(this.path + "/:id/:prop", this.ensureLoggedIn(this.entity, repo_actions_enum_1.RepoActions.delete), (req, res) => {
            if (!this.isAuthorize(req, res, repo_actions_enum_1.RepoActions.delete)) {
                this.sendUnauthorizeError(res, 'unauthorize access for resource ' + this.path);
                return;
            }
            return this.repository.delete(req.params.id)
                .then(result => {
                this.sendresult(req, res, result);
            }).catch(error => {
                console.log(error);
                this.sendError(res, error);
            });
        });
        // add or update any property value
        exports_1.router.put(this.path + "/:id", this.ensureLoggedIn(this.entity, repo_actions_enum_1.RepoActions.put), (req, res) => {
            if (!this.isAuthorize(req, res, repo_actions_enum_1.RepoActions.put)) {
                this.sendUnauthorizeError(res, 'unauthorize access for resource ' + this.path);
                return;
            }
            this.getModelFromHalModel(req.body, req, res);
            return this.repository.put(req.params.id, req.body)
                .then((result) => {
                var resourceName = this.getFullBaseUrl(req); // + this.repository.modelName();
                this.getHalModel1(result, resourceName, req, this.repository);
                this.sendresult(req, res, result);
            }).catch(error => {
                console.log(error);
                this.sendError(res, error);
            });
        });
        // add or update any property value
        exports_1.router.put(this.path, this.ensureLoggedIn(this.entity, repo_actions_enum_1.RepoActions.put), (req, res) => {
            if (!this.isAuthorize(req, res, repo_actions_enum_1.RepoActions.put)) {
                this.sendUnauthorizeError(res, 'unauthorize access for resource ' + this.path);
                return;
            }
            if (!Array.isArray(req.body)) {
                this.sendError(res, 'Invalid data.');
                return;
            }
            Enumerable.from(req.body).forEach(x => {
                this.getModelFromHalModel(x, req, res);
            });
            return this.repository.bulkPut(req.body)
                .then((result) => {
                this.sendresult(req, res, result);
            }).catch(error => {
                console.log(error);
                this.sendError(res, error);
            });
        });
        exports_1.router.delete(this.path + "/:id", this.ensureLoggedIn(this.entity, repo_actions_enum_1.RepoActions.delete), (req, res) => {
            if (!this.isAuthorize(req, res, repo_actions_enum_1.RepoActions.delete)) {
                this.sendUnauthorizeError(res, 'unauthorize access for resource ' + this.path);
                return;
            }
            return this.repository.delete(req.params.id)
                .then((result) => {
                this.sendresult(req, res, result);
            }).catch(error => {
                console.log(error);
                this.sendError(res, error);
            });
        });
        // bulk delete
        exports_1.router.delete(this.path, this.ensureLoggedIn(this.entity, repo_actions_enum_1.RepoActions.delete), (req, res) => {
            if (!this.isAuthorize(req, res, repo_actions_enum_1.RepoActions.delete)) {
                this.sendUnauthorizeError(res, 'unauthorize access for resource ' + this.path);
                return;
            }
            if (!Array.isArray(req.body)) {
                this.sendError(res, 'Invalid data.');
                return;
            }
            var ids = req.body;
            if (ids.length == 0) {
                this.sendError(res, 'Invalid data.');
                return;
            }
            return this.repository.bulkDel(ids)
                .then((result) => {
                this.sendresult(req, res, result);
            }).catch(error => {
                console.log(error);
                this.sendError(res, error);
            });
        });
        exports_1.router.patch(this.path + "/:id", this.ensureLoggedIn(this.entity, repo_actions_enum_1.RepoActions.patch), (req, res) => {
            if (!this.isAuthorize(req, res, repo_actions_enum_1.RepoActions.patch)) {
                this.sendUnauthorizeError(res, 'unauthorize access for resource ' + this.path);
                return;
            }
            this.getModelFromHalModel(req.body, req, res);
            return this.repository.patch(req.params.id, req.body)
                .then((result) => {
                var resourceName = this.getFullBaseUrl(req); // + this.repository.modelName();
                this.getHalModel1(result, resourceName, req, this.repository);
                this.sendresult(req, res, result);
            }).catch(error => {
                this.sendError(res, error);
            });
        });
    }
    addSearchPaths() {
        let modelRepo = this.repository.getEntityType();
        let decoratorFields = utils_1.MetaUtils.getMetaData(modelRepo.model.prototype, decorators_1.Decorators.FIELD);
        let fieldsWithSearchIndex = Enumerable.from(decoratorFields)
            .where(ele => {
            var meta = ele;
            return meta.propertyKey
                && meta
                && meta.params
                && meta.params.searchIndex;
        }).toArray();
        let searchPropMap = searchUtils_1.GetAllFindBySearchFromPrototype(modelRepo);
        var search = {};
        searchPropMap.forEach(map => {
            this.addRoutesForAllSearch(map, fieldsWithSearchIndex);
            search[map.key] = { "href": map.key, "params": map.args };
        });
        exports_1.router.get(this.path + "/searchAll", this.ensureLoggedIn(this.entity, repo_actions_enum_1.RepoActions.findAll), (req, res) => {
            if (!this.isAuthorize(req, res, repo_actions_enum_1.RepoActions.findAll)) {
                this.sendUnauthorizeError(res, 'unauthorize access for resource ' + this.path);
                return;
            }
            return this.searchFromDb(req, res, repo_actions_enum_1.RepoActions.findAll);
        });
        exports_1.router.get(this.path + "/count", this.ensureLoggedIn(this.entity, repo_actions_enum_1.RepoActions.findAll), (req, res) => {
            if (!this.isAuthorize(req, res, repo_actions_enum_1.RepoActions.findAll)) {
                this.sendUnauthorizeError(res, 'unauthorize access for resource ' + this.path);
                return;
            }
            return this.countFromDb(req, res);
        });
        exports_1.router.get(this.path + "/search", this.ensureLoggedIn(this.entity, 'search'), (req, res) => {
            let links = { "self": { "href": this.getFullBaseUrlUsingRepo(req, this.repository.modelName()) + "/search" } };
            for (var prop in search) {
                var lnk = {};
                lnk['href'] = this.getFullBaseUrlUsingRepo(req, this.repository.modelName()) + "/search/" + search[prop]["href"];
                lnk['params'] = search[prop]['params'];
                links[prop] = lnk;
            }
            this.sendresult(req, res, links);
        });
    }
    countFromDb(req, res) {
        var resourceName = this.getFullBaseUrlUsingRepo(req, this.repository.modelName());
        var queryObj = req.query;
        var options = {};
        return this.repository.countWhere(queryObj).then((count) => {
            this.sendresult(req, res, { result: count });
        });
    }
    addActionPaths() {
        let modelRepo = this.repository.getEntityType();
        let searchPropMap = actionUtils_1.GetAllActionFromPrototype(modelRepo);
        var actions = {};
        searchPropMap.forEach(map => {
            var meta = utils_1.MetaUtils.getMetaData(this.entity, decorators_1.Decorators.UPLOAD, map.key);
            if (meta) {
                meta.params.destination;
                exports_1.router.post(this.path + "/action/" + map.key, this.ensureLoggedIn(this.entity, map.key), multer({
                    storage: multer.diskStorage({
                        destination: function (req, file, callback) {
                            callback(null, meta.params.destination);
                        }
                    })
                }).any(), (req, res) => {
                    Enumerable.from(req.query).forEach((x) => {
                        req.body[x.key] = x.value;
                    });
                    this.actionPathRender(req, res, map, modelRepo, actions, true);
                });
            }
            else {
                exports_1.router.post(this.path + "/action/" + map.key, this.ensureLoggedIn(this.entity, map.key), (req, res) => {
                    this.actionPathRender(req, res, map, modelRepo, actions, false);
                });
                exports_1.router.put(this.path + "/action/" + map.key, this.ensureLoggedIn(this.entity, map.key), (req, res) => {
                    this.actionPathRender(req, res, map, modelRepo, actions, false);
                });
            }
            actions[map.key] = { "href": map.key, "params": map.args };
        });
        exports_1.router.get(this.path + "/action", this.ensureLoggedIn(this.entity, 'action'), (req, res) => {
            let links = { "self": { "href": this.getFullBaseUrlUsingRepo(req, this.repository.modelName()) + "/action" } };
            for (var prop in actions) {
                var lnk = {};
                lnk["href"] = this.getFullBaseUrlUsingRepo(req, this.repository.modelName()) + "/action/" + actions[prop]["href"];
                lnk['params'] = actions[prop]["params"];
                links[prop] = lnk;
            }
            this.sendresult(req, res, links);
        });
    }
    actionPathRender(req, res, map, modelRepo, actions, hasFiles) {
        if (!this.isAuthorize(req, res, map.key)) {
            this.sendUnauthorizeError(res, 'unauthorize access for resource ' + this.path + "/action/" + map.key);
            return;
        }
        if (req.method == "POST") {
            this.ensureALLRequiredPresent(modelRepo.model.prototype, req.body, req, res);
        }
        this.removeJSONIgnore(modelRepo.model.prototype, req.body, req);
        this.invokeModelFunction(map, req, res, actions, hasFiles);
    }
    mergeEntity(req) {
        return this.repository.findOne(req.body.id).then(result => {
            return Object.keys(result).forEach(attribute => {
                if (!req.body[attribute]) {
                    req.body[attribute] = result[attribute];
                }
            });
        }).catch(error => {
            winstonLog_1.winstonLog.logError('[DynamicController: mergeEntity]: mergeEntity error ' + error);
        });
    }
    invokeModelFunction(map, req, res, actions, hasFiles) {
        try {
            let modelRepo = this.repository.getEntityType();
            var param = [];
            if (hasFiles) {
                param.push(req.files);
            }
            for (var prop in req.body) {
                param.push(req.body[prop]);
            }
            param.push(req);
            var ret = modelRepo[map.key].apply(modelRepo, param);
            if (Utils.isPromise(ret)) {
                var prom = ret;
                prom.then(x => {
                    this.sendresult(req, res, x);
                }).catch(err => {
                    this.sendError(res, err);
                });
                ;
            }
            else {
                this.sendresult(req, res, ret);
            }
        }
        catch (err) {
            this.sendError(res, err);
        }
    }
    addRoutesForAllSearch(map, fieldsWithSearchIndex) {
        let searchFromDb = true;
        if (configUtil.config().Config.ApplyElasticSearch) {
            let areAllSearchFieldsIndexed = Enumerable.from(map.args).intersect(fieldsWithSearchIndex).count() == map.args.length;
            searchFromDb = !areAllSearchFieldsIndexed;
        }
        // If all the search fields are not indexed in the elasticsearch, return data from the database
        // Keeping different router.get to avoid unncessary closure at runtime
        if (searchFromDb) {
            exports_1.router.get(this.path + "/search/" + map.key, this.ensureLoggedIn(this.entity, map.key), (req, res) => {
                return this.isPreAuthenticated(req, res, map.key).then(isAllowed => {
                    if (isAllowed) {
                        return this.searchFromDb(req, res, map.key);
                    }
                });
            });
        }
        else {
            let model = this.repository.getModel();
            exports_1.router.get(this.path + "/search/" + map.key, (req, res) => {
                return this.isPreAuthenticated(req, res, map.key).then(isAllowed => {
                    if (isAllowed) {
                        return this.searchUsingElastic(req, res, model, map);
                    }
                });
            });
        }
    }
    isPreAuthenticated(req, res, propertyKey) {
        var meta = utils_1.MetaUtils.getMetaData(this.entity, decorators_1.Decorators.ALLOWANONYMOUS, propertyKey);
        if (meta)
            return Q.when(true);
        meta = utils_1.MetaUtils.getMetaData(this.entity, decorators_1.Decorators.PREAUTHORIZE, propertyKey);
        if (meta) {
            return pre_auth_service_1.PreAuthService.isPreAuthenticated([req.body], meta.params, propertyKey).then(isAllowed => {
                if (!isAllowed) {
                    this.sendUnauthorizeError(res, 'unauthorize access for resource ' + this.path);
                }
                return isAllowed;
            });
        }
        return Q.when(true);
    }
    postFilter(result, propertyKey) {
        var meta = utils_1.MetaUtils.getMetaData(this.entity, decorators_1.Decorators.POSTFILTER, propertyKey);
        if (meta) {
            return post_filter_service_1.PostFilterService.postFilter(result, meta.params);
        }
        return Q.when(result);
    }
    searchFromDb(req, res, propertyKey) {
        var resourceName = this.getFullBaseUrlUsingRepo(req, this.repository.modelName());
        var queryObj = req.query;
        var options = {};
        Enumerable.from(queryObj).forEach((x) => {
            if (queryOptions_1.filterProps.indexOf(x.key) >= 0) {
                options[x.key] = x.value;
                delete queryObj[x.key];
            }
            else {
                var val = queryObj[x.key];
                var i = val.indexOf('%LIKE%');
                if (i == 0) {
                    // contains
                    val = val.replace('%LIKE%', '');
                    queryObj[x.key] = {
                        $regex: '.*' + val + '.*'
                    };
                }
                else {
                    i = val.indexOf('%START%');
                    if (i == 0) {
                        // starts with
                        val = val.replace('%START%', '');
                        queryObj[x.key] = {
                            $regex: '^' + val + '.*'
                        };
                    }
                }
            }
        });
        console.log("Querying Database");
        return this.repository
            .findWhere(queryObj, null, options)
            .then(result => {
            return this.postFilter(result, propertyKey);
        })
            .then((result) => {
            result.forEach(obj => {
                this.getHalModel1(obj, resourceName + "/" + obj["_id"], req, this.repository);
            });
            this.sendresult(req, res, result);
        });
    }
    searchUsingElastic(req, res, model, map) {
        let queryObj = req.query;
        let musts = map.args.map(function (arg) {
            let s = '{"' + arg + '":' + "0" + "}";
            let obj = JSON.parse(s);
            obj[arg] = queryObj[arg];
            return { "match": obj };
        });
        let query = {
            "query": {
                "bool": {
                    "must": musts
                }
            }
        };
        winstonLog_1.winstonLog.logInfo('[DynamicController: addRoutesForAllSearch]: query ' + JSON.stringify(query));
        console.log("Querying Elastic search with %s", JSON.stringify(query));
        return model
            .search(query, (err, rr) => {
            if (err) {
                console.error(err);
                this.sendresult(req, res, err);
            }
            else {
                console.log(rr);
                this.postFilter(rr, map.key).then(result => {
                    this.sendresult(req, res, result);
                });
            }
        });
    }
    getHalModel(model, resourceName) {
        var selfUrl = {};
        selfUrl["href"] = resourceName + "/" + model._id;
        var selfObjec = {};
        selfObjec["self"] = selfUrl;
        model["_links"] = selfObjec;
        return model;
    }
    getModelFromHalModel(model, req, res) {
        if (model["_links"]) {
            delete model["_links"];
        }
        //code to handle jsonignore
        let modelRepo = this.repository.getEntityType();
        //code to handle @required fields.
        if (req.method == "POST") {
            this.ensureALLRequiredPresent(modelRepo.model.prototype, model, req, res);
        }
        this.removeJSONIgnore(modelRepo.model.prototype, model, req);
        //code to change url to id, for relations.
        if (req.method != "GET") {
            this.changeUrlToId(model, modelRepo.model.prototype);
        }
    }
    changeUrlToId(model, entity) {
        var relations = Utils.getAllRelationsForTargetInternal(entity) || [];
        relations.forEach(relation => {
            var param = relation.params;
            if (!model[relation.propertyKey])
                return;
            if (model[relation.propertyKey] instanceof Array) {
                var allElements = model[relation.propertyKey];
                if (allElements instanceof Array) {
                    allElements.forEach((element, index) => {
                        var arrElement = {};
                        arrElement['value'] = element;
                        this.trimUrl(arrElement, param);
                        allElements[index] = arrElement['value'];
                    });
                }
                return;
            }
            var element = {};
            element['value'] = model[relation.propertyKey];
            this.trimUrl(element, param);
            model[relation.propertyKey] = element['value'];
        });
    }
    trimUrl(element, param) {
        if (element.value instanceof Object) {
            this.changeUrlToId(element.value, param.itemType);
        }
        else {
            if (element.value.indexOf('http') > -1 && element.value.indexOf('/') > -1) {
                element.value = element.value.trim();
                element.value = element.value.split("/").pop();
            }
        }
    }
    getHalModel1(model, resourceName, req, repo) {
        var selfUrl = {};
        selfUrl["href"] = resourceName; // + "/" + model._id;
        model["_links"] = {};
        model["_links"]["self"] = selfUrl;
        //add associations 
        //read metadata and get all relations names
        let modelRepo = repo.getEntityType();
        this.removeJSONIgnore(modelRepo.model.prototype, model, req);
        var relations = Utils.getAllRelationsForTargetInternal(modelRepo.model.prototype) || [];
        relations.forEach(relation => {
            var relUrl = {};
            relUrl["href"] = resourceName + "/" + relation.propertyKey;
            model["_links"][relation.propertyKey] = relUrl;
            var repo = dynamic_repository_1.GetRepositoryForName(relation.params.rel);
            if (repo) {
                var param = relation.params;
                if (!param.embedded && !param.eagerLoading) {
                    return model;
                }
                if (model[relation.propertyKey] instanceof Array) {
                    if (model[relation.propertyKey] && model[relation.propertyKey].length && Utils.isJSON(model[relation.propertyKey][0])) {
                        model[relation.propertyKey].forEach(key => {
                            var url = this.getFullBaseUrlUsingRepo(req, repo.modelName());
                            this.getHalModel1(key, url + '/' + key['_id'], req, repo);
                        });
                    }
                }
                else {
                    if (model[relation.propertyKey] && Utils.isJSON(model[relation.propertyKey])) {
                        var url = this.getFullBaseUrlUsingRepo(req, repo.modelName());
                        this.getHalModel1(model[relation.propertyKey], url + '/' + model[relation.propertyKey]['_id'], req, repo);
                    }
                }
            }
        });
        return model;
    }
    removeJSONIgnore(entity, model, req) {
        if (!model)
            return;
        this.jsonIgnoreModels(entity, model, req);
        var relations = Utils.getAllRelationsForTargetInternal(entity) || [];
        relations.forEach(relation => {
            var param = relation.params;
            if (param.embedded || param.eagerLoading) {
                this.removeJSONIgnore(param.itemType, model[relation.propertyKey], req);
            }
        });
    }
    jsonIgnoreModels(entity, model, req) {
        var decFields = utils_1.MetaUtils.getMetaData(entity, decorators_1.Decorators.JSONIGNORE);
        if (decFields) {
            decFields.forEach(field => {
                if (model instanceof Array) {
                    model.forEach(mod => {
                        this.removePropertyFromModel(mod, field, req);
                    });
                }
                else {
                    this.removePropertyFromModel(model, field, req);
                }
            });
        }
    }
    removePropertyFromModel(model, field, req) {
        var jsonIgnoreParams = field.params;
        if (jsonIgnoreParams && jsonIgnoreParams == jsonignore_enum_1.JsonIgnore.READ && req.method != 'GET') {
            if (model[field.propertyKey]) {
                delete model[field.propertyKey];
            }
        }
        if (Object.keys(jsonIgnoreParams).length == 0 && model[field.propertyKey]) {
            delete model[field.propertyKey];
        }
    }
    ensureALLRequiredPresent(entity, model, req, res) {
        if (!model)
            return;
        var decFields = utils_1.MetaUtils.getMetaData(entity, decorators_1.Decorators.REQUIRED);
        if (decFields) {
            decFields.forEach(field => {
                if (model instanceof Array) {
                    model.forEach(mod => {
                        if (mod instanceof Object && !mod[field.propertyKey]) {
                            this.sendBadRequest(res, "required field not present in model");
                        }
                    });
                }
                else {
                    if (model instanceof Object && !model[field.propertyKey]) {
                        this.sendBadRequest(res, "required field not present in model");
                    }
                }
            });
        }
        var relations = Utils.getAllRelationsForTargetInternal(entity) || [];
        relations.forEach(relation => {
            var param = relation.params;
            if (param.embedded || param.eagerLoading) {
                this.ensureALLRequiredPresent(param.itemType, model[relation.propertyKey], req, res);
            }
        });
    }
    getHalModels(models, resourceName) {
        var halresult = {};
        halresult["_links"] = { "self": { "href": resourceName }, "search": { "href": "/search" } };
        models.forEach(model => {
            this.getHalModel(model, resourceName);
        });
        halresult["_embedded"] = models;
        return halresult;
    }
    sendUnauthorizeError(res, error) {
        winstonLog_1.winstonLog.logError('[DynamicController: sendUnauthorizeError]: authorization error ' + error);
        res.set("Content-Type", "application/json");
        res.send(403, JSON.stringify(error, null, 4));
    }
    sendError(res, error) {
        winstonLog_1.winstonLog.logError('[DynamicController: sendError]: error ' + error);
        res.set("Content-Type", "application/json");
        res.send(500, JSON.stringify(error, null, 4));
    }
    sendBadRequest(res, error) {
        winstonLog_1.winstonLog.logError('[DynamicController: sendBadRequest]: bad request ' + error);
        res.set("Content-Type", "application/json");
        res.send(400, JSON.stringify(error, null, 4));
    }
    sendresult(req, res, result) {
        res.set("Content-Type", "application/json");
        res.send(JSON.stringify(result, null, 4));
    }
    getFullDataUrl(req) {
        var fullbaseUr = "";
        fullbaseUr = this.getProtocol(req) + '://' + req.get('host') + "/" + configUtil.config().Config.basePath;
        return fullbaseUr;
    }
    getFullBaseUrl(req) {
        var fullbaseUr = "";
        fullbaseUr = this.getProtocol(req) + '://' + req.get('host') + req.originalUrl;
        return fullbaseUr;
    }
    getFullBaseUrlUsingRepo(req, repoName) {
        var fullbaseUr = "";
        fullbaseUr = this.getProtocol(req) + '://' + req.get('host') + '/' + configUtil.config().Config.basePath + '/' + repoName;
        return fullbaseUr;
    }
    getProtocol(req) {
        if (req.headers && req.headers["x-arr-ssl"]) {
            return "https";
        }
        else {
            return req.protocol;
        }
    }
}
exports.DynamicController = DynamicController;

//# sourceMappingURL=dynamic-controller.js.map
