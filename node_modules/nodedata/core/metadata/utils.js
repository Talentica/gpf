"use strict";
const enums_1 = require('../enums');
const winstonLog_1 = require('../../logging/winstonLog');
const constants_1 = require('../constants');
const Enumerable = require('linq');
const metadata_1 = require('./metadata');
let _metadataRoot = new Map();
let _nameAndTargetMapping = {};
let _documnetNameAndTargetMapping = {};
let childProcessId;
function metadataRoot(metadataRoot) {
    if (metadataRoot !== undefined) {
        _metadataRoot = metadataRoot;
    }
    return _metadataRoot;
}
exports.metadataRoot = metadataRoot;
function getMetaPropKey(decoratorType, propertyKey, paramIndex) {
    let metaPropKey = propertyKey;
    if (decoratorType === enums_1.DecoratorType.METHOD && !propertyKey) {
        winstonLog_1.winstonLog.logError('propertyKey should not be null for method decorator');
        throw TypeError('propertyKey should not be null for method decorator');
    }
    if (decoratorType === enums_1.DecoratorType.PARAM && (paramIndex === null || paramIndex === undefined || paramIndex < 0)) {
        winstonLog_1.winstonLog.logError('paramIndex should be greater than equal to 0 for param decorator');
        throw TypeError('paramIndex should be greater than equal to 0 for param decorator');
    }
    if (decoratorType === enums_1.DecoratorType.CLASS || (decoratorType === enums_1.DecoratorType.PARAM && !propertyKey)) {
        metaPropKey = constants_1.MetadataConstants.CLASSDECORATOR_PROPKEY;
    }
    if (decoratorType === enums_1.DecoratorType.PARAM) {
        // special case for param decorators
        metaPropKey = metaPropKey + constants_1.MetadataConstants.PROPKEY_PARAMINDEX_JOIN + paramIndex;
    }
    return metaPropKey;
}
exports.getMetaPropKey = getMetaPropKey;
class MetadataHelper {
    /**
     * Add any encountered metadata to the metadata root for later usage.
     * @param {(Object|Function)} target The function or function prototype where decorator is defined.
     * @param decorator The name of the decorator.
     * @param {DecoratorType} decoratorType The type of the decorator.
     * @param {Object} params The decorator params.
     * @param {string} [propertyKey] The property/parameter/method name.
     * @param {number} [paramIndex] The index if the decorator is paramter decorator.
     * @throws {TypeError} Target cannot be null.
     * @throws {TypeError} PropertyKey cannot be null for method/paramter decorator.
     */
    static addMetaData(target, metaOptions) {
        if (!target) {
            winstonLog_1.winstonLog.logError('target cannot be null/undefined');
            throw TypeError('target cannot be null/undefined');
        }
        if (!metaOptions.propertyKey && (metaOptions.decoratorType === enums_1.DecoratorType.PROPERTY || metaOptions.decoratorType === enums_1.DecoratorType.METHOD)) {
            winstonLog_1.winstonLog.logError('propertyKey cannot be null or undefined for method/property decorator');
            throw TypeError('propertyKey cannot be null or undefined for method/property decorator');
        }
        if (target.name) {
            _nameAndTargetMapping[target.name] = target;
        }
        else if (target.constructor.name) {
            _nameAndTargetMapping[target.constructor.name] = target;
        }
        if (metaOptions.decorator == "document" && metaOptions.params && metaOptions.params.name) {
            _documnetNameAndTargetMapping[metaOptions.params.name] = target;
        }
        let metaPropKey = getMetaPropKey(metaOptions.decoratorType, metaOptions.propertyKey, metaOptions.paramIndex);
        let metaKey = MetadataHelper.getMetaKey(target);
        let decoratorMetadata = _metadataRoot.get(metaKey) ? _metadataRoot.get(metaKey) : {};
        decoratorMetadata[metaOptions.decorator] = decoratorMetadata[metaOptions.decorator] || {};
        if (decoratorMetadata[metaOptions.decorator][metaPropKey]) {
            // Metadata for given combination already exists.
            return false;
        }
        let metaTarget = MetadataHelper.isFunction(target) ? target.prototype : target;
        let metadata = new metadata_1.MetaData(metaTarget, MetadataHelper.isFunction(target), metaOptions);
        decoratorMetadata[metaOptions.decorator][metaPropKey] = metadata;
        _metadataRoot.set(metaKey, decoratorMetadata);
        return true;
    }
    /**
     * Get the metadata for the given target with the given decorator name and property/method name.
     * @param {(Object|Function)} target The function or function prototype where decorator is defined.
     * @param {string} decorator
     * @param {string} [propertyKey] Property/Method name where decorator is defined.
     * Returns class level MetaData for decorator if null/undefined.
     * @param {string} paramIndex The index of the parameter in case of param decorator.
     * @returns {MetaData} The metadata for the given target, decorator and propertyKey.
     */
    static getMetaData(target, decorator, propertyKey, paramIndex) {
        switch (arguments.length) {
            case 1: return MetadataHelper.getMetaDataForTarget(target);
            case 2: return MetadataHelper.getAllMetaDataForDecorator(target, decorator);
            case 3: return MetadataHelper.getMetaDataForTargetDecoratorAndPropKey(enums_1.DecoratorType.METHOD, target, decorator, propertyKey, paramIndex);
            case 4: return MetadataHelper.getMetaDataForTargetDecoratorAndPropKey(enums_1.DecoratorType.PARAM, target, decorator, propertyKey, paramIndex);
        }
    }
    static getMetaDataFromType(modelType) {
        if (_documnetNameAndTargetMapping[modelType])
            return MetadataHelper.getMetaDataForTarget(_documnetNameAndTargetMapping[modelType]);
        if (_nameAndTargetMapping[modelType])
            return MetadataHelper.getMetaDataForTarget(_nameAndTargetMapping[modelType]);
    }
    /**
     *
     * @param decorator
     */
    static getMetaDataForDecorators(decorators) {
        var returnObj = [];
        if (!(decorators && decorators.length)) {
            return returnObj;
        }
        for (let key of _metadataRoot.keys()) {
            var metaArrForKey = Enumerable.from(_metadataRoot.get(key)) // decoratormetadata: { [key: string]: { [key: string]: MetaData } };
                .where(keyVal => decorators.indexOf(keyVal.key) !== -1)
                .selectMany(keyval => {
                return keyval.value;
            }) //{ [key: string]: MetaData }
                .select(keyVal => keyVal.value)
                .toArray();
            if (metaArrForKey.length) {
                returnObj.push({ target: key, metadata: metaArrForKey });
            }
        }
        return returnObj;
    }
    static getMetaDataForPropKey(target, propertyKey, paramIndex) {
        if (!target) {
            winstonLog_1.winstonLog.logError('target cannot be null');
            throw TypeError('target cannot be null');
        }
        propertyKey = propertyKey || constants_1.MetadataConstants.CLASSDECORATOR_PROPKEY;
        var metaKey = MetadataHelper.getMetaKey(target);
        if (!_metadataRoot.get(metaKey)) {
            return null;
        }
        return Enumerable.from(_metadataRoot.get(metaKey))
            .selectMany(keyval => keyval.value) // keyval = {[key(decoratorName): string]: {[key(propName)]: Metadata}};
            .where(keyVal => keyVal.key === propertyKey) // keyval = {[key(propName): string]: Metadata};
            .select(keyVal => keyVal.value) // keyval = {[key(propName): string]: Metadata};
            .toArray();
    }
    static refreshDerivedObjectsMetadata() {
        var documents = MetadataHelper.getMetaDataForDecorators([constants_1.Decorators.DOCUMENT]);
        var proto = '__proto__';
        Enumerable.from(documents).forEach(x => {
            var tar = x.metadata[0].target;
            var pro = tar[proto];
            console.log(tar);
            while (pro != null) {
                var met = MetadataHelper.getMetaData(pro);
                Enumerable.from(met).forEach((prop) => {
                    MetadataHelper.addMetaData(tar, {
                        propertyKey: prop.propertyKey,
                        paramIndex: prop.paramIndex,
                        decorator: prop.decorator,
                        decoratorType: prop.decoratorType,
                        params: prop.params,
                        type: prop.propertyType,
                        returnType: prop.returnType,
                        paramTypes: prop.paramTypes
                    });
                });
                pro = pro[proto];
            }
        });
    }
    static getMetaDataForTarget(target) {
        if (!target) {
            winstonLog_1.winstonLog.logError('target cannot be null or undefined');
            throw TypeError('target cannot be null or undefined');
        }
        var metaKey = MetadataHelper.getMetaKey(target);
        if (!_metadataRoot.get(metaKey)) {
            return null;
        }
        return Enumerable.from(_metadataRoot.get(metaKey))
            .selectMany(keyval => keyval.value)
            .select(keyVal => keyVal.value)
            .toArray();
    }
    static getAllMetaDataForDecorator(target, decorator) {
        if (!target || !decorator) {
            winstonLog_1.winstonLog.logError('target and decorator cannot be null or undefined');
            throw TypeError('target and decorator cannot be null or undefined');
        }
        var metaKey = MetadataHelper.getMetaKey(target);
        if (!_metadataRoot.get(metaKey)) {
            return null;
        }
        return Enumerable.from(_metadataRoot.get(metaKey)[decorator])
            .select(keyVal => keyVal.value)
            .toArray();
    }
    static getMetaDataForTargetDecoratorAndPropKey(decoratorType, target, decorator, propertyKey, paramIndex) {
        if (!target || !decorator) {
            winstonLog_1.winstonLog.logError('target and decorator cannot be null or undefined');
            throw TypeError('target and decorator cannot be null or undefined');
        }
        let metaPropKey = getMetaPropKey(decoratorType, propertyKey, paramIndex);
        var metaKey = MetadataHelper.getMetaKey(target);
        if (!_metadataRoot.get(metaKey)) {
            return null;
        }
        if (_metadataRoot.get(metaKey)[decorator]) {
            return _metadataRoot.get(metaKey)[decorator][metaPropKey];
        }
        return null;
    }
    static getMetaKey(target) {
        return MetadataHelper.isFunction(target) ? target.prototype : target;
    }
    static isFunction(target) {
        if (typeof target === 'function') {
            return true;
        }
        return false;
    }
    static getDescriptiveMetadata(type, baseRelMeta, recursionLevel) {
        var metas;
        metas = exports.MetaUtils.getMetaDataFromType(type);
        //var props: { [key: string]: MetaData } = <any>{};
        var metaData = {};
        var properties = [];
        Enumerable.from(metas).forEach(x => {
            var m = x;
            if (m.decoratorType == enums_1.DecoratorType.PROPERTY) {
                var params = m.params;
                var info = {};
                info['name'] = m.propertyKey;
                if (params && params.rel) {
                    if (baseRelMeta) {
                        var relMeta = baseRelMeta + m.getType().name;
                        info['href'] = relMeta;
                    }
                    info['subtype'] = m.getType().name;
                    info['type'] = m.propertyType.isArray ? "Array" : "Object";
                    if (!recursionLevel) {
                        info['metadata'] = this.getDescriptiveMetadata(params.itemType.name, baseRelMeta, 1);
                        recursionLevel = undefined;
                    }
                    if (recursionLevel && recursionLevel <= 4) {
                        recursionLevel += 1;
                        info['metadata'] = this.getDescriptiveMetadata(params.itemType.name, baseRelMeta, recursionLevel);
                        recursionLevel = undefined;
                    }
                }
                else {
                    info['type'] = m.propertyType.isArray ? "Array" : m.getType().name;
                    if (info['type'] != "String" && info['type'] != "Boolean" &&
                        info['type'] != "Number" && info['type'] != "Date" &&
                        info['type'] != "Object" && info['type'] != "Array") {
                        info['type'] = m.propertyType.isArray ? "Array" : "Object";
                        info['subtype'] = m.getType().name;
                        if (!recursionLevel) {
                            info['metadata'] = this.getDescriptiveMetadata(m.getType().name, baseRelMeta, 1);
                            recursionLevel = undefined;
                        }
                    }
                }
                properties.push(info);
            }
        });
        metaData['id'] = type;
        metaData['properties'] = properties;
        return metaData;
    }
}
exports.MetaUtils = MetadataHelper;

//# sourceMappingURL=utils.js.map
