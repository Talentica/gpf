{"version":3,"sources":["core/metadata/utils.ts"],"names":[],"mappings":"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","file":"core/metadata/utils.js","sourcesContent":["import {ParamTypeCustom} from './param-type-custom';\nimport {DecoratorType} from '../enums';\nimport {winstonLog} from '../../logging/winstonLog';\nimport {Decorators, MetadataConstants} from '../constants';\nimport * as Enumerable from 'linq';\nimport {MetaRoot} from '../metadata/interfaces/metaroot';\nimport {MetaData, IMetaOptions} from './metadata';\nimport {DecoratorMetaData} from '../metadata/interfaces/decorator-metadata';\nimport * as ReflectUtils from '../reflect/reflect-utils';\n\nimport {IAssociationParams} from '../decorators/interfaces/association-params';\nimport {IRepositoryParams} from '../decorators/interfaces/repository-params';\n\nlet _metadataRoot: MetaRoot = new Map<Function | Object, DecoratorMetaData>();\nlet _nameAndTargetMapping: any = {};\nlet _documnetNameAndTargetMapping: any = {};\n\nlet childProcessId:any;\n\nexport function metadataRoot(metadataRoot?): MetaRoot {\n    if (metadataRoot !== undefined) {\n        _metadataRoot = metadataRoot;\n    }\n    return _metadataRoot;\n}\n\nexport function getMetaPropKey(decoratorType, propertyKey?, paramIndex?) {\n    let metaPropKey = propertyKey;\n\n    if (decoratorType === DecoratorType.METHOD && !propertyKey) {\n        winstonLog.logError('propertyKey should not be null for method decorator');\n        throw TypeError('propertyKey should not be null for method decorator');\n    }\n    if (decoratorType === DecoratorType.PARAM && (paramIndex === null || paramIndex === undefined || paramIndex < 0)) {\n        winstonLog.logError('paramIndex should be greater than equal to 0 for param decorator');\n        throw TypeError('paramIndex should be greater than equal to 0 for param decorator');\n    }\n    if (decoratorType === DecoratorType.CLASS || (decoratorType === DecoratorType.PARAM && !propertyKey)) {\n        metaPropKey = MetadataConstants.CLASSDECORATOR_PROPKEY;\n    }\n    if (decoratorType === DecoratorType.PARAM) {\n        // special case for param decorators\n        metaPropKey = metaPropKey + MetadataConstants.PROPKEY_PARAMINDEX_JOIN + paramIndex;\n    }\n    return metaPropKey;\n}\n\ninterface IMetadataHelper {\n    childProcessId:any;\n    addMetaData(target: Object | Function, metaOptions: IMetaOptions): boolean;\n\n    getMetaData(target: Object): Array<MetaData>;\n    getMetaDataFromType(modelType: string): Array<MetaData>;\n    getMetaData(target: Object, decorator: string): Array<MetaData>;\n    getMetaData(target: Object, decorator: string, propertyKey: string): MetaData;\n    getMetaData(target: Object, decorator: string, propertyKey: string, paramIndex: number): MetaData;\n    getMetaDataForDecorators(decorators: Array<string>): Array<{ target: Object, metadata: Array<MetaData> }>;\n    getMetaDataForPropKey(target: Object, propertyKey?: string): Array<MetaData>;\n    getMetaDataForPropKey(target: Object, propertyKey?: string, paramIndex?: number): Array<MetaData>;\n    refreshDerivedObjectsMetadata();\n    getDescriptiveMetadata(type, baseRelMeta, recursionLevel?: number): any;\n}\n\nclass MetadataHelper {\n    public static childProcessId:any;\n    /**\n     * Add any encountered metadata to the metadata root for later usage.\n     * @param {(Object|Function)} target The function or function prototype where decorator is defined.\n     * @param decorator The name of the decorator.\n     * @param {DecoratorType} decoratorType The type of the decorator.\n     * @param {Object} params The decorator params.\n     * @param {string} [propertyKey] The property/parameter/method name.\n     * @param {number} [paramIndex] The index if the decorator is paramter decorator.\n     * @throws {TypeError} Target cannot be null.\n     * @throws {TypeError} PropertyKey cannot be null for method/paramter decorator.\n     */\n    public static addMetaData(target: Object | Function, metaOptions: IMetaOptions): boolean {\n        if (!target) {\n            winstonLog.logError('target cannot be null/undefined');\n            throw TypeError('target cannot be null/undefined');\n        }\n\n        if (!metaOptions.propertyKey && (metaOptions.decoratorType === DecoratorType.PROPERTY || metaOptions.decoratorType === DecoratorType.METHOD)) {\n            winstonLog.logError('propertyKey cannot be null or undefined for method/property decorator');\n            throw TypeError('propertyKey cannot be null or undefined for method/property decorator');\n        }\n        if ((<any>target).name) {\n            _nameAndTargetMapping[(<any>target).name] = target;\n        } else if (target.constructor.name) {\n            _nameAndTargetMapping[(<any>target).constructor.name] = target;\n        }\n        if (metaOptions.decorator == \"document\" && metaOptions.params && metaOptions.params.name ) {\n            _documnetNameAndTargetMapping[metaOptions.params.name] = target;\n        }\n\n        let metaPropKey = getMetaPropKey(metaOptions.decoratorType, metaOptions.propertyKey, metaOptions.paramIndex);\n\n        let metaKey = MetadataHelper.getMetaKey(target);\n\n        let decoratorMetadata: DecoratorMetaData = _metadataRoot.get(metaKey) ? _metadataRoot.get(metaKey) : {};\n        decoratorMetadata[metaOptions.decorator] = decoratorMetadata[metaOptions.decorator] || {};\n        if (decoratorMetadata[metaOptions.decorator][metaPropKey]) {\n            // Metadata for given combination already exists.\n            return false;\n        }\n        let metaTarget = MetadataHelper.isFunction(target) ? (<Function>target).prototype : target;\n        let metadata: MetaData = new MetaData(\n            metaTarget,\n            MetadataHelper.isFunction(target),\n            metaOptions);\n        decoratorMetadata[metaOptions.decorator][metaPropKey] = metadata;\n        _metadataRoot.set(metaKey, decoratorMetadata);\n        return true;\n    }\n\n    /**\n     * Get the metadata for the given target with the given decorator name and property/method name.\n     * @param {(Object|Function)} target The function or function prototype where decorator is defined.\n     * @param {string} decorator\n     * @param {string} [propertyKey] Property/Method name where decorator is defined.\n     * Returns class level MetaData for decorator if null/undefined.\n     * @param {string} paramIndex The index of the parameter in case of param decorator.\n     * @returns {MetaData} The metadata for the given target, decorator and propertyKey.\n     */\n    public static getMetaData(target: Object, decorator?: string, propertyKey?: string, paramIndex?: number): any {\n        switch (arguments.length) {\n            case 1: return MetadataHelper.getMetaDataForTarget(target);\n            case 2: return MetadataHelper.getAllMetaDataForDecorator(target, decorator);\n            case 3: return MetadataHelper.getMetaDataForTargetDecoratorAndPropKey(DecoratorType.METHOD, target, decorator, propertyKey, paramIndex);\n            case 4: return MetadataHelper.getMetaDataForTargetDecoratorAndPropKey(DecoratorType.PARAM, target, decorator, propertyKey, paramIndex);\n        }\n    }\n\n    public static getMetaDataFromType(modelType: string): Array<MetaData> {\n        if (_documnetNameAndTargetMapping[modelType])\n            return MetadataHelper.getMetaDataForTarget(_documnetNameAndTargetMapping[modelType]);\n\n        if (_nameAndTargetMapping[modelType])\n            return MetadataHelper.getMetaDataForTarget(_nameAndTargetMapping[modelType]);\n    }\n\n    /**\n     * \n     * @param decorator\n     */\n    public static getMetaDataForDecorators(decorators: Array<string>): Array<{ target: Object, metadata: Array<MetaData> }> {\n        var returnObj = [];\n        if (!(decorators && decorators.length)){\n            return returnObj;\n        }\n        for (let key of _metadataRoot.keys()) {\n            var metaArrForKey = Enumerable.from(_metadataRoot.get(key)) // decoratormetadata: { [key: string]: { [key: string]: MetaData } };\n                .where(keyVal => decorators.indexOf(keyVal.key) !== -1)\n                .selectMany(keyval => {\n                    return keyval.value;\n                }) //{ [key: string]: MetaData }\n                .select(keyVal => keyVal.value)\n                .toArray();\n            if (metaArrForKey.length) {\n                returnObj.push({ target: key, metadata: metaArrForKey });\n            }\n        }\n        return returnObj;\n    }\n\n    public static getMetaDataForPropKey(target: Object, propertyKey?: string, paramIndex?: number): Array<MetaData> {\n        if (!target) {\n            winstonLog.logError('target cannot be null');\n            throw TypeError('target cannot be null');\n        }\n\n        propertyKey = propertyKey || MetadataConstants.CLASSDECORATOR_PROPKEY;\n        var metaKey = MetadataHelper.getMetaKey(target);\n        if (!_metadataRoot.get(metaKey)) {\n            return null;\n        }\n\n        return Enumerable.from(_metadataRoot.get(metaKey))\n            .selectMany(keyval => keyval.value) // keyval = {[key(decoratorName): string]: {[key(propName)]: Metadata}};\n            .where(keyVal => keyVal.key === propertyKey) // keyval = {[key(propName): string]: Metadata};\n            .select(keyVal => keyVal.value) // keyval = {[key(propName): string]: Metadata};\n            .toArray();\n    }\n\n    public static refreshDerivedObjectsMetadata() {\n        var documents = MetadataHelper.getMetaDataForDecorators([Decorators.DOCUMENT]);\n        var proto = '__proto__';\n        Enumerable.from(documents).forEach(x => {\n            var tar = x.metadata[0].target;\n            var pro = tar[proto];\n            console.log(tar);\n            while (pro != null) {\n                var met = MetadataHelper.getMetaData(pro);\n                Enumerable.from(met).forEach((prop: any) => {\n                    MetadataHelper.addMetaData(tar,\n                        {\n                            propertyKey: prop.propertyKey,\n                            paramIndex: prop.paramIndex,\n                            decorator: prop.decorator,\n                            decoratorType: prop.decoratorType,\n                            params: prop.params,\n                            type: prop.propertyType,\n                            returnType: prop.returnType,\n                            paramTypes: prop.paramTypes\n                        });\n                });\n                pro = pro[proto];\n            }\n        });\n    }\n\n    private static getMetaDataForTarget(target: Object): Array<MetaData> {\n        if (!target) {\n            winstonLog.logError('target cannot be null or undefined');\n            throw TypeError('target cannot be null or undefined');\n        }\n\n        var metaKey = MetadataHelper.getMetaKey(target);\n\n        if (!_metadataRoot.get(metaKey)) {\n            return null;\n        }\n\n        return Enumerable.from(_metadataRoot.get(metaKey))\n            .selectMany(keyval => keyval.value)\n            .select(keyVal => keyVal.value)\n            .toArray();\n    }\n\n    private static getAllMetaDataForDecorator(target: Object, decorator: string): Array<MetaData> {\n        if (!target || !decorator) {\n            winstonLog.logError('target and decorator cannot be null or undefined');\n            throw TypeError('target and decorator cannot be null or undefined');\n        }\n\n        var metaKey = MetadataHelper.getMetaKey(target);\n\n        if (!_metadataRoot.get(metaKey)) {\n            return null;\n        }\n\n        return Enumerable.from(_metadataRoot.get(metaKey)[decorator])\n            .select(keyVal => keyVal.value)\n            .toArray();\n    }\n\n    private static getMetaDataForTargetDecoratorAndPropKey(\n        decoratorType: DecoratorType,\n        target: Object,\n        decorator: string,\n        propertyKey: string,\n        paramIndex?: number\n    ): MetaData {\n        if (!target || !decorator) {\n            winstonLog.logError('target and decorator cannot be null or undefined');\n            throw TypeError('target and decorator cannot be null or undefined');\n        }\n\n        let metaPropKey = getMetaPropKey(decoratorType, propertyKey, paramIndex);\n\n        var metaKey = MetadataHelper.getMetaKey(target);\n        if (!_metadataRoot.get(metaKey)) {\n            return null;\n        }\n        if (_metadataRoot.get(metaKey)[decorator]) {\n            return _metadataRoot.get(metaKey)[decorator][metaPropKey];\n        }\n        return null;\n    }\n\n    private static getMetaKey(target: Function | Object): Object {\n        return MetadataHelper.isFunction(target) ? (<Function>target).prototype : target;\n    }\n\n    private static isFunction(target: Function | Object) {\n        if (typeof target === 'function') {\n            return true;\n        }\n        return false;\n    }\n\n\n    public static getDescriptiveMetadata(type, baseRelMeta, recursionLevel?: number): any {\n        var metas;\n\n        metas = MetaUtils.getMetaDataFromType(type);\n        //var props: { [key: string]: MetaData } = <any>{};\n\n        var metaData = {};\n\n        var properties = [];\n        Enumerable.from(metas).forEach(x => {\n            var m = x as MetaData;\n            if (m.decoratorType == DecoratorType.PROPERTY) {\n                var params: IAssociationParams = <IAssociationParams>m.params;\n                var info = {};\n                info['name'] = m.propertyKey;\n                if (params && params.rel) {\n\n                    if (baseRelMeta) {\n                        var relMeta = baseRelMeta + m.getType().name;\n                        info['href'] = relMeta;\n                    }\n\n                    info['subtype'] = m.getType().name;\n                    info['type'] = m.propertyType.isArray ? \"Array\" : \"Object\";\n                    if (!recursionLevel) {\n                        info['metadata'] = this.getDescriptiveMetadata((<any>params.itemType).name, baseRelMeta, 1);\n                        recursionLevel = undefined;\n                    }\n                    if (recursionLevel && recursionLevel <= 4) {\n                        recursionLevel += 1;\n                        info['metadata'] = this.getDescriptiveMetadata((<any>params.itemType).name, baseRelMeta, recursionLevel);\n                        recursionLevel = undefined;\n                    }\n                }\n                else {\n\n\n                    info['type'] = m.propertyType.isArray ? \"Array\" : m.getType().name;\n                    if (info['type'] != \"String\" && info['type'] != \"Boolean\" &&\n                        info['type'] != \"Number\" && info['type'] != \"Date\" &&\n                        info['type'] != \"Object\" && info['type'] != \"Array\") {\n                        info['type'] = m.propertyType.isArray ? \"Array\" : \"Object\";\n                        info['subtype'] = m.getType().name;\n                        if (!recursionLevel) {\n                            info['metadata'] = this.getDescriptiveMetadata(m.getType().name, baseRelMeta, 1);\n                            recursionLevel = undefined;\n                        }\n\n                    }\n\n\n                    //info['rstype'] = m.getType().name;\n                    //info['type'] =  m.propertyType.isArray ? [m.getType().name] : m.getType().name;\n                }\n                properties.push(info);\n\n            }\n        });\n        metaData['id'] = type;\n        metaData['properties'] = properties;\n       \n        return metaData;\n    }\n\n\n}\n\nexport var MetaUtils: IMetadataHelper = MetadataHelper;\n"],"sourceRoot":"/source/"}