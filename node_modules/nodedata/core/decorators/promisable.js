"use strict";
const utils_1 = require("../metadata/utils");
const decorators_1 = require('../constants/decorators');
const decorator_type_1 = require('../enums/decorator-type');
const Utils = require('../../mongoose/utils');
const CoreUtils = require("../utils");
const model_entity_1 = require('../../core/dynamic/model-entity');
const dynamic_repository_1 = require('../dynamic/dynamic-repository');
const Q = require('q');
function promisable(params) {
    params = params || {};
    return function (target, propertyKey, parameterIndex) {
        utils_1.MetaUtils.addMetaData(target, {
            decorator: decorators_1.Decorators.PROMISABLE,
            decoratorType: decorator_type_1.DecoratorType.PROPERTY,
            params: params,
            propertyKey: propertyKey
        });
        var getter = function (refresh) {
            // find the target property from params.targetKey
            // find the relavent repository from the relationship and fetch all entity data from db
            var allReferencingEntities = CoreUtils.getAllRelationsForTargetInternal(model_entity_1.getEntity(this.constructor.name));
            let targetProperties = allReferencingEntities.filter((x) => x.propertyKey === params.targetKey);
            if (!targetProperties) {
                return Q.reject(`the targer property ${params.targetKey} either does not exist or does not have any relationship asscociated with it.`);
            }
            let targerPropertyMeta = targetProperties[0];
            let ghostKey = "__ghostKey_" + params.targetKey;
            let ghostKeyData = undefined;
            //// if target property already have object filled then no need to fetch again
            //if (targerPropertyMeta.params.embedded || targerPropertyMeta.params.eagerLoading) {
            //    return Q.when(this[params.targetKey]);
            //}
            if (!refresh && this[ghostKey]) {
                return this[ghostKey];
            }
            let repo = dynamic_repository_1.GetRepositoryForName(targerPropertyMeta.params.rel);
            if (!repo) {
                return Q.reject(`the targer property ${params.targetKey}'s model's repository does not exist.`);
            }
            if (!Object.getOwnPropertyDescriptor(this, ghostKey)) {
                Object.defineProperty(this, ghostKey, {
                    get: () => {
                        return ghostKeyData;
                    },
                    set: (val) => {
                        ghostKeyData = val;
                    }
                });
            }
            // case for onetomany, manytomany relationship type
            if (targerPropertyMeta.propertyType.isArray) {
                let ids = [];
                if (!this[params.targetKey] || !this[params.targetKey].length) {
                    return Q.when([]);
                }
                if (Utils.isBasonOrStringType(this[params.targetKey][0])) {
                    ids = this[params.targetKey];
                }
                else {
                    ids = this[params.targetKey].map(x => x._id);
                }
                return repo.getRootRepo().findMany(ids, true).then(results => {
                    this[ghostKey] = results;
                    return Q.when(results);
                }).catch(exc => {
                    return Q.reject(exc);
                });
            }
            else {
                let id = "";
                if (!this[params.targetKey]) {
                    Q.when({});
                }
                if (Utils.isBasonOrStringType(this[params.targetKey])) {
                    id = this[params.targetKey];
                }
                else {
                    id = this[params.targetKey]._id;
                }
                return repo.getRootRepo().findOne(id).then(result => {
                    this[ghostKey] = result;
                    return Q.when(result);
                }).catch(exc => {
                    return Q.reject(exc);
                });
                ;
            }
        };
        target[propertyKey] = getter;
    };
}
exports.promisable = promisable;

//# sourceMappingURL=promisable.js.map
