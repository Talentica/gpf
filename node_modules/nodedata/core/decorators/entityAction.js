"use strict";
const utils_1 = require("../metadata/utils");
const decorators_1 = require('../constants/decorators');
const decorator_type_1 = require('../enums/decorator-type');
const principalContext_1 = require('../../security/auth/principalContext');
const pre_auth_service_1 = require('../services/pre-auth-service');
const post_filter_service_1 = require('../services/post-filter-service');
const instance_service_1 = require('../services/instance-service');
const Utils = require('../utils');
const repo_actions_enum_1 = require('../enums/repo-actions-enum');
const Enumerable = require('linq');
const Q = require('q');
const mongoose_1 = require("mongoose");
function entityAction(params) {
    params = params || {};
    return function (target, propertyKey, descriptor) {
        utils_1.MetaUtils.addMetaData(target, {
            decorator: decorators_1.Decorators.PREAUTHORIZE,
            decoratorType: decorator_type_1.DecoratorType.METHOD,
            params: params,
            propertyKey: propertyKey
        });
        var originalMethod = descriptor.value;
        descriptor.value = function () {
            var anonymous = utils_1.MetaUtils.getMetaData(target, decorators_1.Decorators.ALLOWANONYMOUS, propertyKey);
            if (anonymous)
                return originalMethod.apply(this, arguments);
            let args = [];
            args = Array.apply(null, arguments);
            // merge logic
            return mergeTask.apply(this, [args, originalMethod]).then(fullyQualifiedEntities => {
                //if (originalMethod.name === RepoActions.findOne) {
                //    var ret = service.target[preAuthParam.methodName].apply(service.target, params);
                //}
                let findActions = [repo_actions_enum_1.RepoActions.findAll, repo_actions_enum_1.RepoActions.findByField, repo_actions_enum_1.RepoActions.findChild, repo_actions_enum_1.RepoActions.findMany,
                    repo_actions_enum_1.RepoActions.findOne, repo_actions_enum_1.RepoActions.findWhere];
                // Converting Repo method names into uppercase as check with original method name is in uppercase.
                // This is require othewise it will go in else condition and some of the entities will visible user without access e.g. questionnaire not assigned ot user.
                findActions = findActions.map(methodName => methodName.toUpperCase());
                if (findActions.indexOf(originalMethod.name.toUpperCase()) >= 0) {
                    return post_filter_service_1.PostFilterService.postFilter(fullyQualifiedEntities, params).then(result => {
                        if (!result) {
                            fullyQualifiedEntities = null;
                        }
                        if (result instanceof Array) {
                            let ids = result.map(x => x._id.toString());
                            // select only entities which have access
                            fullyQualifiedEntities = Enumerable.from(fullyQualifiedEntities).where((x) => ids.indexOf(x.newPersistentEntity._id.toString()) != -1).toArray();
                        }
                        if (args.length) {
                            args[args.length - 1] = fullyQualifiedEntities;
                        }
                        else {
                            args[0] = fullyQualifiedEntities;
                        }
                        return originalMethod.apply(this, args);
                    });
                }
                else {
                    return pre_auth_service_1.PreAuthService.isPreAuthenticated([fullyQualifiedEntities], params, propertyKey).then(isAllowed => {
                        //req.body = fullyQualifiedEntities;
                        if (isAllowed) {
                            // for delete, post action no need to save merged entity else save merged entity to db
                            //if (originalMethod.name.toUpperCase() != RepoActions.delete.toUpperCase()) {
                            if (args.length) {
                                args[args.length - 1] = fullyQualifiedEntities;
                            }
                            else {
                                args[0] = fullyQualifiedEntities;
                            }
                            //}
                            return originalMethod.apply(this, args);
                        }
                        else {
                            var error = 'unauthorize access for resource';
                            var res = principalContext_1.PrincipalContext.get('res');
                            if (res) {
                                res.set("Content-Type", "application/json");
                                res.send(403, JSON.stringify(error, null, 4));
                            }
                            throw null;
                        }
                    });
                }
            });
        };
        return descriptor;
    };
}
exports.entityAction = entityAction;
function mergeTask(args, method) {
    let prom;
    var response = [];
    let repo = this;
    let rootRepo = repo.getRootRepo();
    switch (method.name.toUpperCase()) {
        case repo_actions_enum_1.RepoActions.findOne.toUpperCase():
            prom = rootRepo.findOne(args[0]).then(res => {
                let mergedEntity = instance_service_1.InstanceService.getInstance(this.getEntity(), null, res);
                return mergeProperties(res, undefined, mergedEntity);
            });
            break;
        case repo_actions_enum_1.RepoActions.findAll.toUpperCase():
            prom = rootRepo.findAll().then((dbEntities) => {
                let mergedEntities = dbEntities.map(x => instance_service_1.InstanceService.getInstance(this.getEntity(), null, x));
                return mergeEntities(dbEntities, undefined, mergedEntities);
            });
            break;
        case repo_actions_enum_1.RepoActions.findWhere.toUpperCase():
            prom = rootRepo.findWhere.apply(rootRepo, args).then((dbEntities) => {
                let mergedEntities = dbEntities.map(x => instance_service_1.InstanceService.getInstance(this.getEntity(), null, x));
                return mergeEntities(dbEntities, undefined, mergedEntities);
            });
            break;
        // TODO: Need to write code for all remaining get entity(s) actions 
        case repo_actions_enum_1.RepoActions.post.toUpperCase():
            // do nothing
            let mergedEntity1 = instance_service_1.InstanceService.getInstance(this.getEntity(), null, args[0]);
            prom = Q.when(mergeProperties(undefined, instance_service_1.InstanceService.getInstance(this.getEntity(), null, args[0]), mergedEntity1));
            break;
        case repo_actions_enum_1.RepoActions.put.toUpperCase():
        case repo_actions_enum_1.RepoActions.patch.toUpperCase():
            // fetch single object
            let entityIdToUpdate = args[0];
            let entityToUpdate = args[1];
            entityToUpdate._id = entityIdToUpdate;
            let mergedEntity = instance_service_1.InstanceService.getInstance(this.getEntity(), null, args[1]);
            prom = rootRepo.findOne(args[0]).then(res => {
                return mergeProperties(res, args[1], mergedEntity);
            });
            break;
        case repo_actions_enum_1.RepoActions.delete.toUpperCase():
            // fetch single object 
            prom = rootRepo.findMany([args[0]], true).then(res => {
                return mergeProperties(res[0], args[0], res[0]);
            });
            break;
        case repo_actions_enum_1.RepoActions.bulkPost.toUpperCase():
            args[0].forEach(x => {
                var mergedEntity1 = instance_service_1.InstanceService.getInstance(this.getEntity(), null, x);
                response.push(mergeProperties(undefined, instance_service_1.InstanceService.getInstance(this.getEntity(), null, x), mergedEntity1));
            });
            prom = Q.when(response);
            break;
        case repo_actions_enum_1.RepoActions.bulkPut.toUpperCase():
            var ids = Enumerable.from(args[0]).select(x => x['_id'].toString()).toArray();
            let mergeEntities1 = [];
            args[0].forEach(x => {
                mergeEntities1.push(instance_service_1.InstanceService.getInstance(this.getEntity(), null, x));
            });
            prom = rootRepo.findMany(ids, true).then(dbEntities => {
                return mergeEntities(dbEntities, args[0], mergeEntities1);
            });
            break;
        case repo_actions_enum_1.RepoActions.bulkDel.toUpperCase():
            if (args[0].length > 0) {
                var ids = [];
                Enumerable.from(args[0]).forEach(x => {
                    if (Utils.isJSON(x)) {
                        ids.push(x['_id']);
                    }
                    else {
                        ids.push(x);
                    }
                });
                prom = rootRepo.findMany(ids).then(dbEntities => {
                    return mergeEntities(undefined, dbEntities, dbEntities);
                });
            }
            else {
                let mergeEntities1 = instance_service_1.InstanceService.getInstance(this.getEntity(), null, args[0]);
                prom = Q.when(mergeProperties(args[0], undefined, mergeEntities1));
            }
            break;
        default:
            prom = Q.when(mergeProperties(args[0], undefined));
            break;
    }
    return prom.then(res => {
        return res;
    }).catch(exc => {
        console.log(exc);
        throw exc;
    });
}
function mergeEntities(dbEntities, entities, mergeEntities1) {
    var res = [];
    if (!entities) {
        dbEntities.forEach(x => {
            res.push(mergeProperties(x, undefined, x));
        });
        return res;
    }
    Enumerable.from(entities).forEach(entity => {
        var dbEntity, mergeEntity;
        if (dbEntities) {
            dbEntity = Enumerable.from(dbEntities).where(x => x['_id'].toString() == entity['_id'].toString()).firstOrDefault();
        }
        if (mergeEntities1) {
            mergeEntity = Enumerable.from(mergeEntities1).where(x => x['_id'].toString() == entity['_id'].toString()).firstOrDefault();
        }
        res.push(mergeProperties(dbEntity, entity, mergeEntity));
    });
    return res;
}
function mergeProperties(dbEntity, entity, mergedEntity) {
    if (!mergedEntity) {
        mergedEntity = {};
    }
    if (dbEntity) {
        for (var prop in dbEntity) {
            mergedEntity[prop] = dbEntity[prop];
        }
    }
    if (entity && (entity instanceof Object && !(entity instanceof mongoose_1.Types.ObjectId))) {
        for (var prop in entity) {
            if (typeof entity[prop] == "Object" && typeof mergedEntity[prop] == "Object") {
                mergedEntity[prop] = this.mergeProperties(mergedEntity[prop], entity[prop]);
            }
            else {
                mergedEntity[prop] = entity[prop];
            }
        }
    }
    return { inputEntity: entity, oldPersistentEntity: dbEntity, newPersistentEntity: mergedEntity };
}

//# sourceMappingURL=entityAction.js.map
