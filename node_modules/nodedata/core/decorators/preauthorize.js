"use strict";
const utils_1 = require("../metadata/utils");
const decorators_1 = require('../constants/decorators');
const decorator_type_1 = require('../enums/decorator-type');
const principalContext_1 = require('../../security/auth/principalContext');
const pre_auth_service_1 = require('../services/pre-auth-service');
const instance_service_1 = require('../services/instance-service');
const Utils = require('../utils');
const repo_actions_enum_1 = require('../enums/repo-actions-enum');
const Enumerable = require('linq');
const Q = require('q');
function preauthorize(params) {
    params = params || {};
    return function (target, propertyKey, descriptor) {
        utils_1.MetaUtils.addMetaData(target, {
            decorator: decorators_1.Decorators.PREAUTHORIZE,
            decoratorType: decorator_type_1.DecoratorType.METHOD,
            params: params,
            propertyKey: propertyKey
        });
        var originalMethod = descriptor.value;
        descriptor.value = function () {
            var anonymous = utils_1.MetaUtils.getMetaData(target, decorators_1.Decorators.ALLOWANONYMOUS, propertyKey);
            if (anonymous)
                return originalMethod.apply(this, arguments);
            let args = [];
            args = Array.apply(null, arguments);
            // merge logic
            return mergeTask.apply(this, [args, originalMethod]).then(fullyQualifiedEntities => {
                return pre_auth_service_1.PreAuthService.isPreAuthenticated([fullyQualifiedEntities], params, propertyKey).then(isAllowed => {
                    //req.body = fullyQualifiedEntities;
                    if (isAllowed) {
                        // for delete, post action no need to save merged entity else save merged entity to db
                        if (originalMethod.name.toUpperCase() != repo_actions_enum_1.RepoActions.delete.toUpperCase() && originalMethod.name.toUpperCase() != repo_actions_enum_1.RepoActions.patch.toUpperCase()) {
                            args[args.length - 1] = fullyQualifiedEntities;
                        }
                        return originalMethod.apply(this, args);
                    }
                    else {
                        var error = 'unauthorize access for resource';
                        var res = principalContext_1.PrincipalContext.get('res');
                        if (res) {
                            res.set("Content-Type", "application/json");
                            res.send(403, JSON.stringify(error, null, 4));
                        }
                        throw null;
                    }
                });
            });
        };
        return descriptor;
    };
}
exports.preauthorize = preauthorize;
function mergeTask(args, method) {
    let prom;
    var response = [];
    switch (method.name.toUpperCase()) {
        case repo_actions_enum_1.RepoActions.post.toUpperCase():
            // do nothing
            prom = Q.when(instance_service_1.InstanceService.getInstance(this.getEntity(), null, args[0]));
            break;
        case repo_actions_enum_1.RepoActions.put.toUpperCase():
        case repo_actions_enum_1.RepoActions.patch.toUpperCase():
            // fetch single object
            prom = this.findMany([args[0]]).then(res => {
                return mergeProperties(res[0], args[1]);
            });
            break;
        case repo_actions_enum_1.RepoActions.delete.toUpperCase():
            // fetch single object 
            prom = this.findMany([args[0]]).then(res => {
                return res[0];
            });
            break;
        case repo_actions_enum_1.RepoActions.bulkPost.toUpperCase():
            args[0].forEach(x => {
                response.push(instance_service_1.InstanceService.getInstance(this.getEntity(), null, x));
            });
            prom = Q.when(response);
            break;
        case repo_actions_enum_1.RepoActions.bulkPut.toUpperCase():
            var ids = Enumerable.from(args[0]).select(x => x['_id'].toString()).toArray();
            prom = this.findMany(ids).then(dbEntities => {
                return mergeEntities(dbEntities, args[0]);
            });
            break;
        case repo_actions_enum_1.RepoActions.bulkDel.toUpperCase():
            if (args[0].length > 0) {
                var ids = [];
                Enumerable.from(args[0]).forEach(x => {
                    if (Utils.isJSON(x)) {
                        ids.push(x['_id']);
                    }
                    else {
                        ids.push(x);
                    }
                });
                prom = this.findMany(ids).then(dbEntities => {
                    return dbEntities;
                });
            }
            else {
                prom = Q.when(args[0]);
            }
            break;
        default:
            prom = Q.when(args[0]);
            break;
    }
    return prom.then(res => {
        return res;
    }).catch(exc => {
        console.log(exc);
        throw exc;
    });
}
function mergeEntities(dbEntities, entities) {
    var res = [];
    Enumerable.from(entities).forEach(entity => {
        var dbEntity = Enumerable.from(dbEntities).where(x => x['_id'] == entity['_id']).firstOrDefault();
        if (dbEntity) {
            res.push(mergeProperties(dbEntity, entity));
        }
        else {
            res.push(entity);
        }
    });
    return res;
}
function mergeProperties(dbEntity, entity) {
    for (var prop in entity) {
        dbEntity[prop] = entity[prop];
    }
    return dbEntity;
}

//# sourceMappingURL=preauthorize.js.map
