"use strict";
const Mongoose = require('mongoose');
const Sequelize = require("sequelize");
const decorators_1 = require('../core/constants/decorators');
const utils_1 = require("../core/metadata/utils");
const sequelizeService_1 = require('./sequelizeService');
class DynamicSchema {
    constructor(target, name, tableSpecs) {
        this._relations = {};
        this.target = target;
        this.schemaName = name;
        this.parsedSchema = this.parse(target);
        this._tablespecs = tableSpecs;
        this._schema = sequelizeService_1.sequelizeService.addScheam(this.schemaName, this.parsedSchema, this._tablespecs);
    }
    getSchema() {
        return this._schema;
    }
    getRelations() {
        return this._relations;
    }
    getTarget() {
        return this.target;
    }
    parse(target) {
        if (!target || !(target instanceof Object)) {
            throw TypeError;
        }
        var schema = {};
        var primaryKeyProp;
        //var metaDataMap = this.getAllMetadataForSchema(target);
        var metaDataMap = utils_1.MetaUtils.getMetaData(this.target, decorators_1.Decorators.COLUMN);
        for (var field in metaDataMap) {
            var fieldMetadata = metaDataMap[field];
            var name = fieldMetadata.params.name;
            var params = fieldMetadata.params;
            delete params.name;
            schema[name] = params;
        }
        var metaDataMap1 = utils_1.MetaUtils.getMetaData(this.target, decorators_1.Decorators.ONETOMANY);
        var oneTomanyrels = [];
        for (var field in metaDataMap1) {
            var fieldMetadata = metaDataMap1[field];
            var params = fieldMetadata.params;
            params.propertyKey = fieldMetadata.propertyKey;
            oneTomanyrels.push(params);
        }
        this._relations[decorators_1.Decorators.ONETOMANY] = oneTomanyrels;
        var metaDataMap2 = utils_1.MetaUtils.getMetaData(this.target, decorators_1.Decorators.MANYTOONE);
        var manytoonerels = [];
        for (var field in metaDataMap2) {
            var fieldMetadata = metaDataMap2[field];
            var params = fieldMetadata.params;
            params.propertyKey = fieldMetadata.propertyKey;
            manytoonerels.push(params);
        }
        this._relations[decorators_1.Decorators.MANYTOONE] = manytoonerels;
        return schema;
    }
    getSearchSchemaTypeForParam(fieldMetadata) {
        var schemaType = this.getSchemaTypeForType(fieldMetadata.getType());
        if (fieldMetadata.params && fieldMetadata.params.rel) {
            return fieldMetadata.propertyType.isArray ? [schemaType] : schemaType;
        }
        else {
            return fieldMetadata.propertyType.isArray ? [schemaType] : { type: schemaType, es_indexed: true };
        }
        //var schemaType = this.getSchemaTypeForType(paramType);
        //if (paramType.rel) {
        //    //var metaData = Utils.getPrimaryKeyMetadata(paramType.itemType);
        //    //var relSchema;
        //    //if ((<any>fieldMetadata.params).embedded) {
        //    //    schema[field] = paramType.isArray ? [Types.Mixed] : Mongoose.Schema.Types.Mixed;
        //    //} else {
        //    //    relSchema = { ref: paramType.rel, type: Mongoose.Schema.Types.ObjectId };
        //    //    schema[field] = paramType.isArray ? [relSchema] : relSchema;
        //    //}
        //    // need to handle embedding vs foreign key refs
        //    return paramType.isArray ? [schemaType] : schemaType;
        //}
        //return paramType.isArray ? [schemaType] : {type : schemaType, es_indexed : true};
    }
    getSchemaTypeForParam(fieldMetadata) {
        var schemaType = this.getSchemaTypeForType(fieldMetadata.getType());
        return fieldMetadata.propertyType.isArray ? [schemaType] : schemaType;
        //var schemaType = this.getSchemaTypeForType(paramType.itemType);
        //if (paramType.rel) {
        //    //var metaData = Utils.getPrimaryKeyMetadata(paramType.itemType);
        //    //var relSchema;
        //    //if ((<any>fieldMetadata.params).embedded) {
        //    //    schema[field] = paramType.isArray ? [Types.Mixed] : Mongoose.Schema.Types.Mixed;
        //    //} else {
        //    //    relSchema = { ref: paramType.rel, type: Mongoose.Schema.Types.ObjectId };
        //    //    schema[field] = paramType.isArray ? [relSchema] : relSchema;
        //    //}
        //    // need to handle embedding vs foreign key refs
        //    return paramType.isArray ? [schemaType] : schemaType;
        //}
        //return paramType.isArray ? [schemaType] : schemaType;
    }
    getSchemaTypeForType(type) {
        switch (type) {
            case Mongoose.Types.ObjectId: return Mongoose.Schema.Types.ObjectId;
            case String: return Sequelize.STRING(128);
            case Number: return Number;
            case Buffer: return Buffer;
            case Date: return Date;
            case Boolean: return Boolean;
            case Array: return Array;
            //case undefined: return Mongoose.Schema.Types.Mixed;
            // any or no types
            case Object:
            default: return Mongoose.Schema.Types.Mixed;
        }
    }
    getMongooseOptions(target) {
        var meta = utils_1.MetaUtils.getMetaData(target, decorators_1.Decorators.ENTITY);
        var entityMeta = meta[0];
        var options = {};
        var params = (entityMeta.params || {});
        options.strict = true;
        return options;
    }
    isSchemaDecorator(decorator) {
        return decorator === decorators_1.Decorators.FIELD || decorator === decorators_1.Decorators.ONETOMANY || decorator === decorators_1.Decorators.MANYTOONE || decorator === decorators_1.Decorators.MANYTOMANY || decorator === decorators_1.Decorators.ONETOONE;
    }
    getAllMetadataForSchema(target) {
        var metaDataMap = utils_1.MetaUtils.getMetaData(target);
        var metaDataMapFiltered = {};
        for (var i in metaDataMap) {
            var meta = metaDataMap[i];
            if (!this.isSchemaDecorator(meta.decorator))
                continue;
            if (metaDataMapFiltered[meta.propertyKey])
                throw "A property cannot have more than one schema decorator";
            metaDataMapFiltered[meta.propertyKey] = meta;
        }
        return metaDataMapFiltered;
    }
}
exports.DynamicSchema = DynamicSchema;

//# sourceMappingURL=dynamic-schema.js.map
