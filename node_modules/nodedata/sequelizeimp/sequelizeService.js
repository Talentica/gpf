"use strict";
const utils_1 = require('../core/utils');
const Sequelize = require("sequelize");
const model_entity_1 = require('../core/dynamic/model-entity');
const constants_1 = require('../core/constants');
const Enumerable = require('linq');
class SequelizeService {
    constructor() {
        this._schemaCollection = {};
        this._relationCollection = [];
    }
    init(force) {
        force = force || false;
        return this.sequelize.sync({ force: force, logging: true });
    }
    connect() {
        if (utils_1.config().SqlConfig.isSqlEnabled == false)
            return;
        this.sequelize = new Sequelize(utils_1.config().SqlConfig.database, utils_1.config().SqlConfig.username, utils_1.config().SqlConfig.password, utils_1.config().SqlConfig.sequlizeSetting);
    }
    getSqlContext() {
        return this.sequelize;
    }
    getCustomResult(databaseName, query) {
        if (utils_1.config().SqlConfig.isSqlEnabled == false)
            return;
        var dynamicSequelize = new Sequelize(databaseName, utils_1.config().SqlConfig.username, utils_1.config().SqlConfig.password, utils_1.config().SqlConfig.sequlizeSetting);
        return dynamicSequelize.query(query);
    }
    addScheam(name, schema, detail) {
        var newSchema = this.sequelize.define(name, schema, detail);
        this._schemaCollection[name] = newSchema;
        return newSchema;
    }
    addRelationInSchema(fromSchema, toSchema, relationType, relationName, path) {
        if (relationType == constants_1.Decorators.ONETOMANY)
            fromSchema.hasMany(toSchema, { as: path });
        if (relationType == constants_1.Decorators.MANYTOONE)
            fromSchema.belongsTo(toSchema, { as: path });
        if (relationType == constants_1.Decorators.ONETOONE)
            fromSchema.has(toSchema, { as: path });
        let relationToDictionary = {};
        relationToDictionary["relation"] = relationName;
        relationToDictionary.fromSchema = fromSchema;
        relationToDictionary.toSchema = toSchema;
        relationToDictionary.path = path;
        this._relationCollection.push(relationToDictionary);
    }
    getModel(repoPath) {
        try {
            var schemaNamefromPathRepomap = model_entity_1.pathRepoMap[repoPath].schemaName;
            return this._schemaCollection[schemaNamefromPathRepomap];
        }
        catch (e) {
            throw e;
        }
    }
    bulkPost(repoPath, objArr) {
        return this.getModel(repoPath).bulkCreate(objArr);
    }
    bulkPutMany(repoPath, objIds, obj) {
        return null;
    }
    bulkDel(repoPath, objArr) {
        return this.getModel(repoPath).destroy({ where: { id: objArr } });
    }
    bulkPut(repoPath, objArr) {
        return this.getModel(repoPath).bulkUpdate(objArr);
    }
    bulkPatch(repoPath, objArr) {
        return this.getModel(repoPath).bulkUpdate(objArr);
    }
    findAll(repoPath) {
        return this.getModel(repoPath).findAll().then(result => {
            if (!result)
                return null;
            var finalOutput = Enumerable.from(result).select((x) => x.dataValues).toArray(); // result.forEach(x => x.dataValues).toArray();
            return finalOutput;
        });
    }
    findWhere(repoPath, query, selectedFields, queryOptions, toLoadChilds) {
        return this.getModel(repoPath).findAll(query).then(result => {
            return result.dataValues;
        });
    }
    //This is not testest yet
    //TODO: add test case for this
    countWhere(repoPath, query) {
        return this.getModel(repoPath).findAndCountAll(query).then(result => {
            return result;
        });
    }
    //This is not testest yet
    //TODO: add test case for this
    distinctWhere(repoPath, query) {
        if (!query) {
            query = {};
        }
        query.distinct = true;
        return this.getModel(repoPath).findAndCountAll(query).then(result => {
            return result;
        });
    }
    findOne(repoPath, id) {
        let schemaModel = this.getModel(repoPath);
        let primaryKey = schemaModel.primaryKeyAttribute;
        var cond = {};
        cond[primaryKey] = id;
        var self = this;
        return schemaModel.find({ include: [{ all: true }], where: cond }).then(result => {
            let model = result.dataValues;
            self.getAssociationForSchema(result, schemaModel);
            return result.dataValues;
        });
    }
    findByField(repoPath, fieldName, value) {
        return this.getModel(repoPath).find({ where: { fieldName: value } });
    }
    findMany(repoPath, ids) {
        return this.getModel(repoPath).findAll({ where: { id: ids } });
    }
    findChild(repoPath, id, prop) {
        return this.getModel(repoPath).find({
            where: { id: id },
            include: [
                { model: this.getModel(prop), as: prop }
            ]
        }).then(function (entity) {
            return entity[prop];
        });
    }
    /**
     * case 1: all new - create main item and child separately and embed if true
     * case 2: some new, some update - create main item and update/create child accordingly and embed if true
     * @param obj
     */
    post(repoPath, obj) {
        return this.getModel(repoPath).create(obj);
    }
    put(repoPath, id, obj) {
        return this.getModel(repoPath).update(obj, { where: { id: id } });
    }
    del(repoPath, id) {
        return this.getModel(repoPath).destroy({ where: { id: id } });
    }
    patch(repoPath, id, obj) {
        return this.getModel(repoPath).update(obj, { where: { id: id } });
    }
    getAssociationForSchema(model, schema) {
        var asyncCalls = [];
        Enumerable.from(this._relationCollection)
            .where(relationSchema => relationSchema.fromSchema == schema).forEach(relation1 => {
            model.dataValues[relation1.path] = model[relation1.toSchema.name + "s"];
        });
        //return Q.allSettled(asyncCalls).then(res => {
        //    return model.dataValues;
        //});
    }
}
exports.sequelizeService = new SequelizeService();
//export var connect = sequelizeService.connect;

//# sourceMappingURL=sequelizeService.js.map
