"use strict";
/// <reference path="../core/dynamic/dynamic-repository.ts" />
const dynamic_schema_1 = require('./dynamic-schema');
const Utils = require('../core/utils');
const utils_1 = require('../core/metadata/utils');
const constants_1 = require('../core/constants');
const constants_2 = require('./constants');
const model_entity_1 = require('../core/dynamic/model-entity');
const Enumerable = require('linq');
const sequelizeService_1 = require('./sequelizeService');
function generateSchema() {
    if (Utils.config().SqlConfig.isSqlEnabled == false)
        return;
    // register entity service
    Utils.entityService(constants_2.Decorators.ENTITY, sequelizeService_1.sequelizeService);
    var entities = utils_1.MetaUtils.getMetaDataForDecorators([constants_1.Decorators.ENTITY]);
    var allDynamicSchemas = new Array();
    entities.forEach(x => {
        let entityMeta = x.metadata[0];
        let schemaName = entityMeta.params.tableName;
        let schema = new dynamic_schema_1.DynamicSchema(entityMeta.target, schemaName, entityMeta.params);
        allDynamicSchemas.push(schema);
        let entitySchema = schema.getSchema();
        //let model = Mongoose.model(schemaName, <any>mongooseSchema);
        model_entity_1.updateModelEntity(schemaName, entityMeta.target, entitySchema, schema);
    });
    allDynamicSchemas.forEach(schema => {
        schema.getRelations()[constants_1.Decorators.ONETOMANY].forEach(oneToManyRelation => {
            let sourceDynamicSchema = schema;
            let targetDynamicSchema = Enumerable.from(allDynamicSchemas)
                .where(dynamicSchema => dynamicSchema.schemaName == oneToManyRelation.rel).first();
            sequelizeService_1.sequelizeService.addRelationInSchema(sourceDynamicSchema.getSchema(), targetDynamicSchema.getSchema(), constants_1.Decorators.ONETOMANY, oneToManyRelation.rel, oneToManyRelation.propertyKey);
        });
    });
    allDynamicSchemas.forEach(schema => {
        schema.getRelations()[constants_1.Decorators.MANYTOONE].forEach(manyToOne => {
            let sourceDynamicSchema = schema;
            let targetDynamicSchema = Enumerable.from(allDynamicSchemas)
                .where(dynamicSchema => dynamicSchema.schemaName == manyToOne.rel).first();
            sequelizeService_1.sequelizeService.addRelationInSchema(sourceDynamicSchema.getSchema(), targetDynamicSchema.getSchema(), constants_1.Decorators.MANYTOONE, manyToOne.rel, manyToOne.propertyKey);
        });
    });
    var repositoryMetadata = utils_1.MetaUtils.getMetaDataForDecorators([constants_1.Decorators.REPOSITORY]);
    repositoryMetadata.forEach(x => {
        if (!x.metadata || !x.metadata.length) {
            return;
        }
        let repositoryParams = x.metadata[0].params;
        let entity = x.metadata[0].params.model;
        let meta = utils_1.MetaUtils.getMetaData(entity, constants_2.Decorators.ENTITY);
        if (meta.length > 0) {
            let entityMeta = meta[0];
            if (entityMeta) {
                let schemaName = entityMeta.params.tableName;
                model_entity_1.pathRepoMap[repositoryParams.path] = { schemaName: schemaName, modelType: constants_2.Decorators.ENTITY };
            }
        }
    });
    sequelizeService_1.sequelizeService.init();
}
exports.generateSchema = generateSchema;
// need to pass this via reference
//    var visitedNodes = new Map();
//    export function validateModels() {
//    var modelsMeta = metaUtils.getMetaDataForDecoratorInAllTargets(Decorators.DOCUMENT);
//    Enumerable.from(modelsMeta).forEach(x => {
//        var m: MetaData = x;
//        var res = this.hasLoop(m.target, new Array<MetaData>());
//        if (res) {
//            throw 'Cannot start server. Please correct the model ' + m.target.constructor.name;
//        }
//    });
//}
//    private function hasLoop(target: Object, vis: Array<MetaData>): boolean {
//        var rel = metaUtils.getAllRelationsForTargetInternal(target);
//        Enumerable.from(rel).forEach(y => {
//            var r: MetaData = <MetaData>y;
//            var param: IAssociationParams = <IAssociationParams>r.params;
//            if (param.embedded || param.eagerLoading) {
//                var res = false;
//                if (this.visitedNodes.has(r)) {
//                    // no need to go ahead, path from this node is already checked
//                    res = false;
//                }
//                else if (vis.indexOf(r) > -1) {
//                    // loop found
//                    res = true;
//                }
//                else {
//                    vis.push(r);
//                    this.visitedNodes.set(r, true);
//                    res = this.hasLoop(param.itemType, vis);
//                }
//                // if any loop 
//                if (res)
//                    return true;
//            }
//        });
//        return false;
//    } 

//# sourceMappingURL=schema.js.map
