"use strict";
let Enumerable = require('linq');
const utils_1 = require('../core/metadata/utils');
const constants_1 = require('../core/constants');
const decorator_type_1 = require('../core/enums/decorator-type');
const Utils = require('../core/utils');
let _extSources = [];
let _depInstMap = new Map();
let _serviceMap = new Map();
function extSources(extSources) {
    if (extSources !== undefined) {
        _extSources = extSources;
    }
    return _extSources;
}
exports.extSources = extSources;
function serviceMap(serviceMap) {
    if (serviceMap !== undefined) {
        _serviceMap = serviceMap;
    }
    return _serviceMap;
}
exports.serviceMap = serviceMap;
//var services: Array<{ fn: Function, params: {} }> = [];
//var serviceInstances: Array<{fn: Function, inst: any}> = [];
function generateToken(fn) {
    return fn.toString();
}
class DependencyNode {
    constructor(data) {
        this.parents = new Map();
        this.children = new Map();
        ;
        this.current = data;
    }
}
let dependencyRoot = new Map();
let dependencyOrder;
class DI {
    constructor() {
        this.stack = [];
    }
    resolveDependencies(cls) {
        if (_serviceMap.has(cls)) {
            return this.resolveServiceDependency(cls, _serviceMap.get(cls));
        }
        return this.getFromExtSources(cls);
    }
    getFromExtSources(cls) {
        let inst;
        _extSources.forEach(func => {
            if (!inst) {
                inst = func.apply(this, [cls]);
            }
        });
        return inst;
    }
    getDependencyOrderString(cls) {
        let arr = [];
        dependencyOrder.forEach((value, key) => {
            arr.push(key.name);
        });
        cls && arr.push(cls.name);
        return arr.join('=>');
    }
    resolveServiceDependency(cls, service) {
        let inst;
        if (!service.singleton) {
            inst = this.instantiateClass(cls);
        }
        inst = this.getInstance(cls);
        if (inst) {
            return inst;
        }
        else {
            inst = this.instantiateClass(cls);
        }
        return inst;
    }
    getInstance(cls) {
        return _depInstMap.get(cls);
    }
    getDependencies(cls) {
        return Enumerable.from(utils_1.MetaUtils.getMetaData(cls.prototype, constants_1.Decorators.INJECT));
    }
    publicDeps(deps) {
        return Enumerable.from(deps)
            .where((x) => x.decoratorType === decorator_type_1.DecoratorType.PROPERTY)
            .toArray();
    }
    constructorDeps(deps) {
        return Enumerable.from(deps)
            .where((x) => x.decoratorType === decorator_type_1.DecoratorType.PARAM)
            .toArray();
    }
    resolveConstructorDeps(deps) {
        let resolvedDeps = [];
        Enumerable.from(deps)
            .orderBy((x) => x.paramIndex)
            .forEach((x) => {
            let type = x.params.type;
            if (type.default) {
                type = type.default;
            }
            if (!type) {
                console.log(x);
                throw 'no type found';
            }
            resolvedDeps.push(this.resolveDependencies(type));
        });
        return resolvedDeps;
    }
    getType(params) {
        let type = params.type;
        if (type.__esModule) {
            type = type.default;
        }
        return type;
    }
    resolvePropDeps(inst, propDeps) {
        Enumerable.from(propDeps)
            .forEach((x) => {
            inst[x.propertyKey] = this.resolveDependencies(x.params.type);
        });
    }
    //private instantiateClass<T extends Function>(fn: T): T {}
    getCycle(parent, child) {
        let arr = Enumerable.from(this.stack)
            .select(x => x.parent.name)
            .toArray();
        arr.push(parent.name, child.name);
        return arr.join(" => ");
    }
    // todo: cyclic dependency
    instantiateClass(cls) {
        console.log('get dependencies: ' + cls.name);
        let allDependencies = this.getDependencies(cls);
        let deps = this.constructorDeps(allDependencies);
        let str = Enumerable.from(deps)
            .select((x) => this.getType(x.params) ? this.getType(x.params).name : ' @ ')
            .toArray()
            .join(",");
        console.log("       " + str);
        if (!dependencyRoot.get(cls)) {
            dependencyRoot.set(cls, new DependencyNode(cls));
        }
        Enumerable.from(deps)
            .forEach((x) => {
            let type = this.getType(x.params);
            if (!dependencyRoot.get(type)) {
                dependencyRoot.set(type, new DependencyNode(type));
            }
            dependencyRoot.get(cls).children.set(type, true);
            if (dependencyRoot.get(type).children.get(cls)) {
                let cycleDepStr = this.getCycle(cls, type);
                throw Error('Cycle found: ' + cycleDepStr);
            }
            dependencyRoot.get(type).parents.set(cls, true);
        });
        this.stack.push({ parent: cls, children: deps });
        let injectedProps = this.publicDeps(allDependencies);
        let resolvedDeps = this.resolveConstructorDeps(deps);
        let inst = Utils.activator(cls, resolvedDeps);
        this.resolvePropDeps(inst, injectedProps);
        _depInstMap.set(cls, inst);
        this.stack.pop();
        return inst;
    }
}
class Container {
    /**
     * Registers all the services, i.e. classes having @service decorator, in the DI container.
     * DI container will inject only those services that are registered with this method.
     * @param {class} cls Typescript class having @service decorator
     * @param {Object} params Decorator params
     */
    static addService(cls, params) {
        _serviceMap.set(cls, params);
    }
    /**
     *
     * @param cls
     */
    static resolve(key) {
        let srvKey = key;
        if (key.__esModule) {
            srvKey = key.default;
        }
        dependencyOrder = dependencyOrder || new Map();
        let di = new DI();
        return di.resolveDependencies(srvKey);
    }
    static addSource(source) {
        _extSources.push(source);
        //source.forEach((x, y) => {
        //    if (_depInstMap.has(y)) {
        //        throw 'key already present in the map';
        //    }
        //    _depInstMap.set(y, x);
        //});
    }
}
exports.Container = Container;

//# sourceMappingURL=di.js.map
