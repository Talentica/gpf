"use strict";
const utils_1 = require('../../core/metadata/utils');
const Utils = require('../../core/utils');
const constants_1 = require('../../core/constants');
const decorator_type_1 = require('../../core/enums/decorator-type');
const _1 = require('../');
let Enumerable = require('linq');
const winstonLog_1 = require('../../logging/winstonLog');
function inject(injectType) {
    function getInjectType(target, propertyKey, parameterIndex, decoratorType) {
        if (injectType) {
            return injectType;
        }
        let type;
        if (decoratorType === decorator_type_1.DecoratorType.PARAM) {
            var paramTypes = Utils.getDesignParamType(target, propertyKey, parameterIndex);
            type = paramTypes && paramTypes.length && parameterIndex < paramTypes.length
                ? paramTypes[parameterIndex]
                : null;
        }
        else if (decoratorType === decorator_type_1.DecoratorType.PROPERTY) {
            type = Utils.getDesignType(target, propertyKey);
        }
        else {
            winstonLog_1.winstonLog.logError(`Error in Injection`);
            throw 'Error';
        }
        if (!type) {
            winstonLog_1.winstonLog.logError(`Error in Injection: inject type cannot be null ${target}`);
            console.log(target);
            throw 'inject type cannot be null';
        }
        return type;
    }
    return function (target, propertyKey, parameterIndex) {
        // param decorator
        if (arguments.length === 3) {
            utils_1.MetaUtils.addMetaData(target, {
                decorator: constants_1.Decorators.INJECT,
                decoratorType: decorator_type_1.DecoratorType.PARAM,
                params: { type: getInjectType(target, propertyKey, parameterIndex, decorator_type_1.DecoratorType.PARAM) },
                propertyKey: propertyKey,
                paramIndex: parameterIndex
            });
            return;
        }
        else {
            injectType = getInjectType(target, propertyKey, parameterIndex, decorator_type_1.DecoratorType.PROPERTY);
            let injectedProp = null;
            // property getter
            var getter = function () {
                if (!injectedProp) {
                    injectedProp = _1.Container.resolve(injectType);
                }
                return injectedProp;
            };
            var setter = function (value) {
                injectedProp = value;
            };
            // Delete property.
            if (!(delete target[propertyKey])) {
                winstonLog_1.winstonLog.logError(`Error in Injection: Invalid property inject`);
                throw "Invalid property inject";
            }
            // Create new property with getter and setter
            Object.defineProperty(target, propertyKey, {
                get: getter,
                set: setter,
                enumerable: true,
                configurable: true
            });
            utils_1.MetaUtils.addMetaData(target, {
                decorator: constants_1.Decorators.INJECT,
                decoratorType: decorator_type_1.DecoratorType.PROPERTY,
                params: { type: injectType },
                propertyKey: propertyKey
            });
        }
    };
}
exports.inject = inject;
function injectbyname(injectName) {
    return function (target, propertyKey, parameterIndex) {
        var injectType = Utils.getDesignType(target, propertyKey);
        // property getter
        let injectedProp = null;
        var getter = function () {
            if (!injectedProp) {
                var metas = utils_1.MetaUtils.getMetaDataForDecorators([constants_1.Decorators.SERVICE]);
                var meta = Enumerable.from(metas).where(x => x.metadata[0].params.serviceName == injectName).select(x => x.metadata[0]).firstOrDefault();
                //injectType = Utils.getDesignParamType(meta.target, undefined);
                injectedProp = _1.Container.resolve(meta.params.target);
            }
            return injectedProp;
        };
        var setter = function (value) {
            injectedProp = value;
        };
        // Delete property.
        if (!(delete target[propertyKey])) {
            winstonLog_1.winstonLog.logError(`Error in Injection: Invalid property inject`);
            throw "Invalid property inject";
        }
        // Create new property with getter and setter
        Object.defineProperty(target, propertyKey, {
            get: getter,
            set: setter,
            enumerable: true,
            configurable: true
        });
        utils_1.MetaUtils.addMetaData(target, {
            decorator: constants_1.Decorators.INJECT,
            decoratorType: decorator_type_1.DecoratorType.PROPERTY,
            params: { type: injectType },
            propertyKey: propertyKey
        });
    };
}
exports.injectbyname = injectbyname;

//# sourceMappingURL=inject.js.map
