"use strict";
const dynamic_schema_1 = require('./dynamic-schema');
const utils_1 = require('../core/metadata/utils');
const constants_1 = require('../core/constants');
const constants_2 = require('./constants');
const mongoose_service_1 = require('./mongoose-service');
const Utils = require('../core/utils');
const model_entity_1 = require('../core/dynamic/model-entity');
const Mongoose = require('mongoose');
function generateSchema() {
    // register mongoose service
    Utils.entityService(constants_2.Decorators.DOCUMENT, new mongoose_service_1.MongooseService());
    var documents = utils_1.MetaUtils.getMetaDataForDecorators([constants_1.Decorators.DOCUMENT]);
    documents.forEach(x => {
        let documentMeta = x.metadata[0];
        let schemaName = documentMeta.params.name;
        let schema = new dynamic_schema_1.DynamicSchema(documentMeta.target, schemaName);
        let mongooseSchema = schema.getSchema();
        let model = Mongoose.model(schemaName, mongooseSchema);
        model_entity_1.updateModelEntity(schemaName, documentMeta.target, model, schema);
    });
    var repositoryMetadata = utils_1.MetaUtils.getMetaDataForDecorators([constants_1.Decorators.REPOSITORY]);
    repositoryMetadata.forEach(x => {
        if (!x.metadata || !x.metadata.length) {
            return;
        }
        let repositoryParams = x.metadata[0].params;
        let entity = x.metadata[0].params.model;
        let meta = utils_1.MetaUtils.getMetaData(entity, constants_2.Decorators.DOCUMENT);
        if (meta.length > 0) {
            let documentMeta = meta[0];
            if (documentMeta) {
                let schemaName = documentMeta.params.name;
                model_entity_1.pathRepoMap[repositoryParams.path] = { schemaName: schemaName, modelType: constants_2.Decorators.DOCUMENT };
            }
        }
    });
}
exports.generateSchema = generateSchema;
// need to pass this via reference
//    var visitedNodes = new Map();
//    export function validateModels() {
//    var modelsMeta = metaUtils.getMetaDataForDecoratorInAllTargets(Decorators.DOCUMENT);
//    Enumerable.from(modelsMeta).forEach(x => {
//        var m: MetaData = x;
//        var res = this.hasLoop(m.target, new Array<MetaData>());
//        if (res) {
//            throw 'Cannot start server. Please correct the model ' + m.target.constructor.name;
//        }
//    });
//}
//    private function hasLoop(target: Object, vis: Array<MetaData>): boolean {
//        var rel = metaUtils.getAllRelationsForTargetInternal(target);
//        Enumerable.from(rel).forEach(y => {
//            var r: MetaData = <MetaData>y;
//            var param: IAssociationParams = <IAssociationParams>r.params;
//            if (param.embedded || param.eagerLoading) {
//                var res = false;
//                if (this.visitedNodes.has(r)) {
//                    // no need to go ahead, path from this node is already checked
//                    res = false;
//                }
//                else if (vis.indexOf(r) > -1) {
//                    // loop found
//                    res = true;
//                }
//                else {
//                    vis.push(r);
//                    this.visitedNodes.set(r, true);
//                    res = this.hasLoop(param.itemType, vis);
//                }
//                // if any loop 
//                if (res)
//                    return true;
//            }
//        });
//        return false;
//    } 

//# sourceMappingURL=schema.js.map
