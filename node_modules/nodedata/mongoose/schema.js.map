{"version":3,"sources":["mongoose/schema.ts"],"names":[],"mappings":"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","file":"mongoose/schema.js","sourcesContent":["import {DynamicSchema} from './dynamic-schema';\nimport {repositoryMap} from '../core/exports';\nimport {MetaUtils} from '../core/metadata/utils';\nimport {Decorators as CoreDecorators} from '../core/constants';\nimport {Decorators} from './constants';\nimport {MongooseService} from './mongoose-service';\nimport * as Utils from '../core/utils';\nimport {IDocumentParams} from './decorators/interfaces/document-params';\nimport {IRepositoryParams} from '../core/decorators/interfaces/repository-params';\nimport {updateModelEntity, pathRepoMap, getModel} from '../core/dynamic/model-entity';\nimport Mongoose = require('mongoose');\n\nexport function generateSchema() {\n\n    // register mongoose service\n    Utils.entityService(Decorators.DOCUMENT, new MongooseService());\n\n    var documents = MetaUtils.getMetaDataForDecorators([CoreDecorators.DOCUMENT]);\n    documents.forEach(x => {\n        let documentMeta = x.metadata[0];\n        let schemaName = (<IDocumentParams>documentMeta.params).name;\n        let schema = new DynamicSchema(documentMeta.target, schemaName);\n        let mongooseSchema = schema.getSchema();\n        let model = Mongoose.model(schemaName, <any>mongooseSchema);\n        updateModelEntity(schemaName, documentMeta.target, model, schema);\n    });\n\n    var repositoryMetadata = MetaUtils.getMetaDataForDecorators([CoreDecorators.REPOSITORY]);\n    repositoryMetadata.forEach(x => {\n        if (!x.metadata || !x.metadata.length) {\n            return;\n        }\n        let repositoryParams = <IRepositoryParams>x.metadata[0].params;\n        let entity = (<IRepositoryParams>x.metadata[0].params).model;\n        let meta = MetaUtils.getMetaData(entity, Decorators.DOCUMENT);\n        if (meta.length > 0) {\n            let documentMeta = meta[0];\n            if (documentMeta) {\n                let schemaName = (<IDocumentParams>documentMeta.params).name;\n                pathRepoMap[repositoryParams.path] = { schemaName: schemaName, modelType: Decorators.DOCUMENT};\n\n            }\n        }\n    });\n}\n\n    // need to pass this via reference\n//    var visitedNodes = new Map();\n\n//    export function validateModels() {\n//    var modelsMeta = metaUtils.getMetaDataForDecoratorInAllTargets(Decorators.DOCUMENT);\n//    Enumerable.from(modelsMeta).forEach(x => {\n//        var m: MetaData = x;\n//        var res = this.hasLoop(m.target, new Array<MetaData>());\n//        if (res) {\n//            throw 'Cannot start server. Please correct the model ' + m.target.constructor.name;\n//        }\n//    });\n//}\n\n//    private function hasLoop(target: Object, vis: Array<MetaData>): boolean {\n//        var rel = metaUtils.getAllRelationsForTargetInternal(target);\n//        Enumerable.from(rel).forEach(y => {\n//            var r: MetaData = <MetaData>y;\n//            var param: IAssociationParams = <IAssociationParams>r.params;\n//            if (param.embedded || param.eagerLoading) {\n//                var res = false;\n//                if (this.visitedNodes.has(r)) {\n//                    // no need to go ahead, path from this node is already checked\n//                    res = false;\n//                }\n//                else if (vis.indexOf(r) > -1) {\n//                    // loop found\n//                    res = true;\n//                }\n//                else {\n//                    vis.push(r);\n//                    this.visitedNodes.set(r, true);\n//                    res = this.hasLoop(param.itemType, vis);\n//                }\n\n//                // if any loop \n//                if (res)\n//                    return true;\n//            }\n//        });\n\n//        return false;\n//    }"],"sourceRoot":"/source/"}