{"version":3,"sources":["mongoose/dynamic-schema.ts"],"names":[],"mappings":";AAAA,MAAO,QAAQ,WAAW,UAAU,CAAC,CAAC;AAEtC,kCAAkC;AAClC,MAAY,UAAU,WAAM,MAAM,CAAC,CAAA;AAEnC,kCAAqB,yBAAyB,CAAC,CAAA;AAC/C,6BAAyB,8BAA8B,CAAC,CAAA;AAGxD,0CAAqD,2BAA2B,CAAC,CAAA;AAEjF,iCAA4B,8BAA8B,CAAC,CAAA;AAC3D,wBAAwB,wBAAwB,CAAC,CAAA;AAIjD;IAKI,YAAY,MAAc,EAAE,IAAY;QACpC,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;QACrB,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;QACvB,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;IAC3C,CAAC;IAEM,SAAS;QACZ,IAAI,YAAY,GAAG,iBAAS,CAAC,WAAW,CAAC,IAAI,CAAC,MAAM,EAAE,uBAAU,CAAC,KAAK,CAAC,CAAC;QACxE,IAAI,GAAG,GAAG,UAAU,CAAC,IAAI,CAAC,YAAY,CAAC;aAClC,KAAK,CAAC,CAAC,MAAM,KAAK,MAAM,IAAI,MAAM,CAAC,MAAM,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,WAAW,CAAC,CAAC,GAAG,EAAE,CAAC;QACjF,IAAI,OAAO,GAAG,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QACnD,IAAI,eAAe,GAA2B,EAAE,OAAO,EAAE,OAAO,EAAE,WAAW,EAAE,GAAG,EAAE,CAAC;QACzF,MAAM,CAAC,yCAAe,CAAC,YAAY,CAAC,IAAI,CAAC,YAAY,EAAE,eAAe,CAAC,CAAC;IAC5E,CAAC;IAEO,KAAK,CAAC,MAAc;QACxB,EAAE,CAAC,CAAC,CAAC,MAAM,IAAI,CAAC,CAAC,MAAM,YAAY,MAAM,CAAC,CAAC,CAAC,CAAC;YACzC,MAAM,SAAS,CAAC;QACpB,CAAC;QACD,IAAI,MAAM,GAAG,EAAE,CAAC;QAChB,IAAI,cAAc,CAAC;QACnB,IAAI,WAAW,GAAG,IAAI,CAAC,uBAAuB,CAAC,MAAM,CAAC,CAAC;QACvD,GAAG,CAAC,CAAC,IAAI,KAAK,IAAI,WAAW,CAAC,CAAC,CAAC;YAC5B,oCAAoC;YACpC,gCAAgC;YAChC,eAAe;YACf,GAAG;YACH,IAAI,aAAa,GAAuB,WAAW,CAAC,KAAK,CAAC,CAAC;YAC3D,EAAE,CAAC,CAAC,aAAa,CAAC,MAAM,IAAU,aAAa,CAAC,MAAO,CAAC,aAAa,CAAC,CAAC,CAAC;gBACpE,QAAQ,CAAC;YACb,CAAC;YACD,EAAE,CAAC,CAAC,aAAa,CAAC,aAAa,KAAK,8BAAa,CAAC,QAAQ,CAAC,CAAC,CAAC;gBACzD,QAAQ,CAAC;YACb,CAAC;YACD,EAAE,CAAC,CAAC,aAAa,CAAC,MAAM,IAAU,aAAa,CAAC,MAAO,CAAC,WAAW,CAAC,CAAC,CAAC;gBAClE,MAAM,CAAC,KAAK,CAAC,GAAG,IAAI,CAAC,2BAA2B,CAAC,aAAa,CAAC,CAAC;YACpE,CAAC;YACD,IAAI,CAAA,CAAC;gBACD,MAAM,CAAC,KAAK,CAAC,GAAG,IAAI,CAAC,qBAAqB,CAAC,aAAa,CAAC,CAAC;YAClE,CAAC;QACD,CAAC;QACD,MAAM,CAAC,MAAM,CAAC;IAClB,CAAC;IAEO,2BAA2B,CAAC,aAAuB;QACvD,IAAI,UAAU,GAAG,IAAI,CAAC,oBAAoB,CAAC,aAAa,CAAC,OAAO,EAAE,CAAC,CAAC;QACpE,EAAE,CAAC,CAAC,aAAa,CAAC,MAAM,IAAI,aAAa,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC;YACnD,MAAM,CAAC,aAAa,CAAC,YAAY,CAAC,OAAO,GAAG,CAAC,UAAU,CAAC,GAAG,UAAU,CAAC;QAC1E,CAAC;QACD,IAAI,CAAC,CAAC;YACF,MAAM,CAAC,aAAa,CAAC,YAAY,CAAC,OAAO,GAAG,CAAC,UAAU,CAAC,GAAG,EAAE,IAAI,EAAE,UAAU,EAAE,UAAU,EAAE,IAAI,EAAE,CAAC;QACtG,CAAC;QACD,wDAAwD;QACxD,sBAAsB;QACtB,uEAAuE;QACvE,sBAAsB;QACtB,mDAAmD;QACnD,4FAA4F;QAC5F,gBAAgB;QAChB,qFAAqF;QACrF,wEAAwE;QACxE,SAAS;QAET,qDAAqD;QACrD,2DAA2D;QAC3D,GAAG;QACH,mFAAmF;IACvF,CAAC;IAEO,qBAAqB,CAAC,aAAuB;QACjD,IAAI,UAAU,GAAG,IAAI,CAAC,oBAAoB,CAAC,aAAa,CAAC,OAAO,EAAE,CAAC,CAAC;QACpE,MAAM,CAAC,aAAa,CAAC,YAAY,CAAC,OAAO,GAAG,CAAC,UAAU,CAAC,GAAG,UAAU,CAAC;QACtE,iEAAiE;QACjE,sBAAsB;QACtB,uEAAuE;QACvE,sBAAsB;QACtB,mDAAmD;QACnD,4FAA4F;QAC5F,gBAAgB;QAChB,qFAAqF;QACrF,wEAAwE;QACxE,SAAS;QAET,qDAAqD;QACrD,2DAA2D;QAC3D,GAAG;QACH,uDAAuD;IAC3D,CAAC;IAEO,oBAAoB,CAAC,IAAK;QAC9B,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;YACX,KAAK,QAAQ,CAAC,KAAK,CAAC,QAAQ,EAAE,MAAM,CAAC,QAAQ,CAAC,MAAM,CAAC,KAAK,CAAC,QAAQ,CAAC;YACpE,KAAK,MAAM,EAAE,MAAM,CAAC,MAAM,CAAC;YAC3B,KAAK,MAAM,EAAE,MAAM,CAAC,MAAM,CAAC;YAC3B,KAAK,MAAM,EAAE,MAAM,CAAC,MAAM,CAAC;YAC3B,KAAK,IAAI,EAAE,MAAM,CAAC,IAAI,CAAC;YACvB,KAAK,OAAO,EAAE,MAAM,CAAC,OAAO,CAAC;YAC7B,KAAK,KAAK,EAAE,MAAM,CAAC,KAAK,CAAC;YACzB,qDAAqD;YACrD,kBAAkB;YAClB,KAAK,MAAM,CAAC;YACZ,SAAS,MAAM,CAAC,QAAQ,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC;QAChD,CAAC;IACL,CAAC;IAEO,kBAAkB,CAAC,MAAc;QACrC,IAAI,IAAI,GAAG,iBAAS,CAAC,WAAW,CAAM,MAAM,EAAE,uBAAU,CAAC,QAAQ,CAAC,CAAC;QACnE,IAAI,YAAY,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;QAC3B,IAAI,OAAO,GAAQ,EAAE,CAAC;QACtB,IAAI,MAAM,GAAoB,CAAC,YAAY,CAAC,MAAM,IAAS,EAAE,CAAC,CAAC;QAC/D,MAAM,CAAC,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC;YACpB,KAAK,wBAAM,CAAC,IAAI;gBAAE,OAAO,CAAC,MAAM,GAAG,IAAI,CAAC;gBAAC,KAAK,CAAC;YAC/C,KAAK,wBAAM,CAAC,KAAK;gBAAE,OAAO,CAAC,MAAM,GAAG,KAAK,CAAC;gBAAC,KAAK,CAAC;YACjD,KAAK,wBAAM,CAAC,KAAK;gBAAE,OAAO,CAAC,MAAM,GAAG,OAAO,CAAC;gBAAC,KAAK,CAAC;YACnD;gBAAS,OAAO,CAAC,MAAM,GAAG,IAAI,CAAC;gBAAC,KAAK,CAAC;QAC1C,CAAC;QACD,MAAM,CAAC,OAAO,CAAC;IACnB,CAAC;IAEO,iBAAiB,CAAC,SAAiB;QACvC,MAAM,CAAC,SAAS,KAAK,uBAAU,CAAC,KAAK,IAAI,SAAS,KAAK,uBAAU,CAAC,SAAS,IAAI,SAAS,KAAK,uBAAU,CAAC,SAAS,IAAI,SAAS,KAAK,uBAAU,CAAC,UAAU,IAAI,SAAS,KAAK,uBAAU,CAAC,QAAQ,CAAC;IAClM,CAAC;IAEO,uBAAuB,CAAC,MAAc;QAC1C,IAAI,WAAW,GAAoB,iBAAS,CAAC,WAAW,CAAM,MAAM,CAAC,CAAC;QACtE,IAAI,mBAAmB,GAAqC,EAAE,CAAC;QAC/D,GAAG,CAAC,CAAC,IAAI,CAAC,IAAI,WAAW,CAAC,CAAC,CAAC;YACxB,IAAI,IAAI,GAAa,WAAW,CAAC,CAAC,CAAa,CAAC;YAEhD,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;gBACxC,QAAQ,CAAC;YAEb,EAAE,CAAC,CAAC,mBAAmB,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;gBACtC,MAAM,uDAAuD,CAAC;YAElE,mBAAmB,CAAC,IAAI,CAAC,WAAW,CAAC,GAAG,IAAI,CAAC;QACjD,CAAC;QACD,MAAM,CAAC,mBAAmB,CAAC;IAC/B,CAAC;AACL,CAAC;AAhJY,qBAAa,gBAgJzB,CAAA","file":"mongoose/dynamic-schema.js","sourcesContent":["import Mongoose = require('mongoose');\n\n//import aa = require('mongoose');\nimport * as Enumerable from 'linq';\nimport * as Types from './datatype';\nimport {Strict} from './enums/document-strict';\nimport {Decorators} from '../core/constants/decorators';\nimport {MetadataConstants} from '../core/constants';\n\nimport {IMongooseSchemaOptions,schemaGenerator} from \"./mongooseSchemaGenerator\";\n\nimport {DecoratorType} from '../core/enums/decorator-type';\nimport {MetaUtils} from \"../core/metadata/utils\";\nimport {MetaData} from '../core/metadata/metadata';\nimport {IDocumentParams} from './decorators/interfaces/document-params';\n\nexport class DynamicSchema {\n    parsedSchema: any;\n    schemaName: string;\n    private target: Object;\n\n    constructor(target: Object, name: string) {\n        this.target = target;\n        this.schemaName = name;\n        this.parsedSchema = this.parse(target);\n    }\n    \n    public getSchema() {\n        var fieldMetaArr = MetaUtils.getMetaData(this.target, Decorators.FIELD);\n        var idx = Enumerable.from(fieldMetaArr)\n            .where((keyVal) => keyVal && keyVal.params && (keyVal.params).searchIndex).any();\n            var options = this.getMongooseOptions(this.target);\n            var mongooseOptions: IMongooseSchemaOptions = { options: options, searchIndex: idx };\n        return schemaGenerator.createSchema(this.parsedSchema, mongooseOptions);\n    }\n\n    private parse(target: Object) {\n        if (!target || !(target instanceof Object)) {\n            throw TypeError;\n        }\n        var schema = {};\n        var primaryKeyProp;\n        var metaDataMap = this.getAllMetadataForSchema(target);\n        for (var field in metaDataMap) {\n            // Skip autogenerated primary column\n            //if (prop === primaryKeyProp) {\n            //    continue;\n            //}\n            var fieldMetadata: MetaData = <MetaData>metaDataMap[field];\n            if (fieldMetadata.params && (<any>fieldMetadata.params).autogenerated) {\n                continue;\n            }\n            if (fieldMetadata.decoratorType !== DecoratorType.PROPERTY) {\n                continue;\n            }\n            if (fieldMetadata.params && (<any>fieldMetadata.params).searchIndex) {\n                schema[field] = this.getSearchSchemaTypeForParam(fieldMetadata);\n            }\n            else{\n                schema[field] = this.getSchemaTypeForParam(fieldMetadata);\n        }\n        }\n        return schema;\n    }\n\n    private getSearchSchemaTypeForParam(fieldMetadata: MetaData):any {\n        var schemaType = this.getSchemaTypeForType(fieldMetadata.getType());\n        if (fieldMetadata.params && fieldMetadata.params.rel) {\n            return fieldMetadata.propertyType.isArray ? [schemaType] : schemaType;\n        }\n        else {\n            return fieldMetadata.propertyType.isArray ? [schemaType] : { type: schemaType, es_indexed: true };\n        }\n        //var schemaType = this.getSchemaTypeForType(paramType);\n        //if (paramType.rel) {\n        //    //var metaData = Utils.getPrimaryKeyMetadata(paramType.itemType);\n        //    //var relSchema;\n        //    //if ((<any>fieldMetadata.params).embedded) {\n        //    //    schema[field] = paramType.isArray ? [Types.Mixed] : Mongoose.Schema.Types.Mixed;\n        //    //} else {\n        //    //    relSchema = { ref: paramType.rel, type: Mongoose.Schema.Types.ObjectId };\n        //    //    schema[field] = paramType.isArray ? [relSchema] : relSchema;\n        //    //}\n\n        //    // need to handle embedding vs foreign key refs\n        //    return paramType.isArray ? [schemaType] : schemaType;\n        //}\n        //return paramType.isArray ? [schemaType] : {type : schemaType, es_indexed : true};\n    }\n\n    private getSchemaTypeForParam(fieldMetadata: MetaData) {\n        var schemaType = this.getSchemaTypeForType(fieldMetadata.getType());\n        return fieldMetadata.propertyType.isArray ? [schemaType] : schemaType;\n        //var schemaType = this.getSchemaTypeForType(paramType.itemType);\n        //if (paramType.rel) {\n        //    //var metaData = Utils.getPrimaryKeyMetadata(paramType.itemType);\n        //    //var relSchema;\n        //    //if ((<any>fieldMetadata.params).embedded) {\n        //    //    schema[field] = paramType.isArray ? [Types.Mixed] : Mongoose.Schema.Types.Mixed;\n        //    //} else {\n        //    //    relSchema = { ref: paramType.rel, type: Mongoose.Schema.Types.ObjectId };\n        //    //    schema[field] = paramType.isArray ? [relSchema] : relSchema;\n        //    //}\n\n        //    // need to handle embedding vs foreign key refs\n        //    return paramType.isArray ? [schemaType] : schemaType;\n        //}\n        //return paramType.isArray ? [schemaType] : schemaType;\n    }\n\n    private getSchemaTypeForType(type?):any {\n        switch (type) {\n            case Mongoose.Types.ObjectId: return Mongoose.Schema.Types.ObjectId;\n            case String: return String;\n            case Number: return Number;\n            case Buffer: return Buffer;\n            case Date: return Date;\n            case Boolean: return Boolean;\n            case Array: return Array;\n            //case undefined: return Mongoose.Schema.Types.Mixed;\n            // any or no types\n            case Object:\n            default: return Mongoose.Schema.Types.Mixed;\n        }\n    }\n\n    private getMongooseOptions(target: Object) {\n        var meta = MetaUtils.getMetaData(<any>target, Decorators.DOCUMENT);\n        var documentMeta = meta[0];\n        var options = <any>{};\n        var params = <IDocumentParams>(documentMeta.params || <any>{});\n        switch (params.strict) {\n            case Strict.true: options.strict = true; break;\n            case Strict.false: options.strict = false; break;\n            case Strict.throw: options.strict = \"throw\"; break;\n            default: options.strict = true; break;\n        }\n        return options;\n    }\n\n    private isSchemaDecorator(decorator: string) {\n        return decorator === Decorators.FIELD || decorator === Decorators.ONETOMANY || decorator === Decorators.MANYTOONE || decorator === Decorators.MANYTOMANY || decorator === Decorators.ONETOONE;\n    }\n\n    private getAllMetadataForSchema(target: Object): { [key: string]: MetaData } {\n        var metaDataMap: Array<MetaData> = MetaUtils.getMetaData(<any>target);\n        var metaDataMapFiltered: { [key: string]: MetaData } = <any>{};\n        for (var i in metaDataMap) {\n            var meta: MetaData = metaDataMap[i] as MetaData;\n\n            if (!this.isSchemaDecorator(meta.decorator))\n                continue;\n\n            if (metaDataMapFiltered[meta.propertyKey])\n                throw \"A property cannot have more than one schema decorator\";\n\n            metaDataMapFiltered[meta.propertyKey] = meta;\n        }\n        return metaDataMapFiltered;\n    }\n}"],"sourceRoot":"/source/"}