"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
/// <reference path="security-utils.ts" />
var express = require('express');
//import UserRepository from '../repositories/userRepository';
const configUtil = require('../../core/utils');
var crypto = require('crypto');
//Passport
var passport = require('passport');
var LocalStrategy = require('passport-local').Strategy;
var FacebookStrategy = require('passport-facebook').Strategy;
var jwt = require('jsonwebtoken');
const exports_1 = require('../../core/exports');
const inject_1 = require('../../di/decorators/inject');
const auth_service_1 = require('./auth-service');
const Utils = require('../../core/utils');
const securityUtils = require('./security-utils');
class AuthController {
    constructor(path) {
        this.db = {
            updateOrCreate: function (user, cb) {
                // we just cb the user
                cb(null, user);
            }
        };
        this.path = path;
        this.addRoutes();
        this.createAuthStrategy();
    }
    createAuthStrategy() {
        this.authService.authenticate();
    }
    getFullBaseUrl(req) {
        var fullbaseUr = "";
        fullbaseUr = this.getProtocol(req) + '://' + req.get('host') + req.originalUrl;
        return fullbaseUr;
    }
    addRoutes() {
        exports_1.router.get('/', securityUtils.ensureLoggedIn(), (req, res) => {
            var aa = this.authService;
            // Display the Login page with any flash message, if any
            res.render('home', { user: req.user });
        });
        exports_1.router.get('/' + configUtil.config().Config.basePath, securityUtils.ensureLoggedIn(), (req, res) => {
            //fetch all resources name (not the model name) in an array
            var allresourcesNames = Utils.getAllResourceNames();
            var allresourceJson = [];
            var fullbaseUrl = "";
            fullbaseUrl = this.getFullBaseUrl(req);
            allresourcesNames.forEach(resource => {
                var resoucejson = {};
                resoucejson[resource] = fullbaseUrl + (resource[0] === '/' ? resource : '/' + resource); //+ tokenUrl;
                allresourceJson.push(resoucejson);
            });
            //loop through rsources and push in json array with name as key and url as value
            res.set("Content-Type", "application/json");
            res.send(JSON.stringify(allresourceJson, null, 4));
        });
        exports_1.router.get('/login', (req, res) => {
            res.render('login');
        });
        exports_1.router.get('/authlogin', (req, res) => {
            res.render('authlogin');
        });
        if (configUtil.config().Security.authenticationType === configUtil.securityConfig().AuthenticationType[configUtil.securityConfig().AuthenticationType.TokenBased]) {
            exports_1.router.post('/login', passport.authenticate("local", {
                session: false
            }), (req, res, next) => this.serialize(req, res, next), (req, res, next) => this.generateToken(req, res, next), (req, res, next) => this.generateRefreshToken(req, res, next), (req, res) => this.authRespond(req, res));
        }
        if (configUtil.config().Security.authenticationType === configUtil.securityConfig().AuthenticationType[configUtil.securityConfig().AuthenticationType.TokenBased]) {
            exports_1.router.post('/authlogin', passport.authenticate("local", {
                session: false
            }), (req, res, next) => this.serialize(req, res, next), (req, res, next) => this.generateToken(req, res, next), (req, res, next) => this.generateRefreshToken(req, res, next), (req, res) => this.authRespond(req, res));
        }
        exports_1.router.get('/token', (req, res, next) => this.validateRefreshToken(req, res, next), (req, res, next) => this.serialize(req, res, next), (req, res, next) => this.generateToken(req, res, next), (req, res) => this.authRespond(req, res));
        if (configUtil.config().Security.authenticationType === configUtil.securityConfig().AuthenticationType[configUtil.securityConfig().AuthenticationType.passwordBased]) {
            exports_1.router.post('/login', passport.authenticate("local"), (req, res) => {
                res.redirect('/' + Utils.config().Config.basePath);
            });
        }
        exports_1.router.get('/logout', (req, res) => {
            req.logout();
            res.redirect('/');
        });
        exports_1.router.post('/register', (req, res) => {
            this.userDetailService.getNewUser(req, res);
        });
    }
    serialize(req, res, next) {
        this.db.updateOrCreate(req.user, function (err, user) {
            if (err) {
                return next(err);
            }
            // we store the updated information in req.user again
            req.user = {
                id: user._id
            };
            next();
        });
    }
    generateToken(req, res, next) {
        req.token = jwt.sign(req.user, configUtil.securityConfig().SecurityConfig.tokenSecretkey, {
            expiresInMinutes: configUtil.securityConfig().SecurityConfig.tokenExpiresInMinutes
        });
        //TODO dont put it in user object in db
        req.user.accessToken = req.token;
        res.cookie('authorization', req.token, { maxAge: 900000, httpOnly: true });
        this.userDetailService.updateExistingUser(req.user.id, req.user).then((user) => {
            req.user = user.getUserObject();
            next();
        }, (error) => {
            return error;
        });
    }
    respond(req, res) {
        res.redirect('/data/');
    }
    authRespond(req, res) {
        var responseJson = {};
        delete req.user.password;
        responseJson['user'] = req.user;
        res.send(responseJson);
    }
    generateRefreshToken(req, res, next) {
        req.user.refreshToken = req.user.id.toString() + '.' + crypto.randomBytes(40).toString('hex');
        //TODO dont put it in user object in db
        res.cookie('refreshToken', req.user.refreshToken, { maxAge: 900000, httpOnly: true });
        this.userDetailService.updateExistingUser(req.user.id, req.user).then((user) => {
            req.user = user.getUserObject();
            next();
        }, (error) => {
            return error;
        });
    }
    validateRefreshToken(req, res, next) {
        this.userDetailService.loadUserByField("refreshToken", req.cookies.refreshToken).then((user) => {
            req.user = user.getUserObject();
            next();
        }, (error) => {
            return error;
        });
    }
    getProtocol(req) {
        if (req.headers && req.headers["x-arr-ssl"]) {
            return "https";
        }
        else {
            return req.protocol;
        }
    }
}
__decorate([
    inject_1.inject(), 
    __metadata('design:type', auth_service_1.AuthService)
], AuthController.prototype, "authService", void 0);
__decorate([
    inject_1.injectbyname("UserDetailService"), 
    __metadata('design:type', Object)
], AuthController.prototype, "userDetailService", void 0);
exports.AuthController = AuthController;

//# sourceMappingURL=authcontroller.js.map
